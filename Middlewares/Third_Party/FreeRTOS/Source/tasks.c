/*
 * FreeRTOS Kernel V10.0.1
 * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */
#include <stdlib.h>
#include <string.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
all the API functions to use the MPU wrappers.  That should only be done when
task.h is included from an application file. */
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "stack_macros.h"

/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
header files above, but not in this file, in order to generate the correct
privileged Vs unprivileged linkage and placement. */
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */

/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
functions but without including stdio.h here. */
#if (configUSE_STATS_FORMATTING_FUNCTIONS == 1)
/* At the bottom of this file are two optional functions that can be used
to generate human readable text from the raw data generated by the
uxTaskGetSystemState() function.  Note the formatting functions are provided
for convenience only, and are NOT considered part of the kernel. */
#include <stdio.h>
#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */

#if (configUSE_PREEMPTION == 0)
/* If the cooperative scheduler is being used then a yield should not be
performed just because a higher priority task has been woken. */
#define taskYIELD_IF_USING_PREEMPTION()
#else
#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
#endif

/* Values that can be assigned to the ucNotifyState member of the TCB. */
// tcb.ucNotifyState的值
#define taskNOT_WAITING_NOTIFICATION ((uint8_t)0)
#define taskWAITING_NOTIFICATION ((uint8_t)1)
#define taskNOTIFICATION_RECEIVED ((uint8_t)2)

/*
 * The value used to fill the stack of a task when the task is created.  This
 * is used purely for checking the high water mark for tasks.
 */
// 填充给任务栈的值
#define tskSTACK_FILL_BYTE (0xa5U)

/* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
dynamically allocated RAM, in which case when any task is deleted it is known
that both the task's stack and TCB need to be freed.  Sometimes the
FreeRTOSConfig.h settings only allow a task to be created using statically
allocated RAM, in which case when any task is deleted it is known that neither
the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
settings allow a task to be created using either statically or dynamically
allocated RAM, in which case a member of the TCB is used to record whether the
stack and/or TCB were allocated statically or dynamically, so when a task is
deleted the RAM that was allocated dynamically is freed again and no attempt is
made to free the RAM that was allocated statically.
tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
task to be created using either statically or dynamically allocated RAM.  Note
that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
a statically allocated stack and a dynamically allocated TCB.
!!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
changed then the definition of StaticTask_t must also be updated. */
// 允许动态和静态分配
#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ((configSUPPORT_STATIC_ALLOCATION == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))
// 动态分配tcb和任务
#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB ((uint8_t)0)
// 只能静态分配任务
#define tskSTATICALLY_ALLOCATED_STACK_ONLY ((uint8_t)1)
////静态分配tcb和任务
#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB ((uint8_t)2)

/* If any of the following are set then task stacks are filled with a known
value so the high water mark can be determined.  If none of the following are
set then don't fill the stack so there is no unnecessary dependency on memset. */
// 以下三个宏被开启，可以用于追踪栈的分配情况，初始化 往栈里面写tskSTACK_FILL_BYTE
#if ((configCHECK_FOR_STACK_OVERFLOW > 1) || (configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))
#define tskSET_NEW_STACKS_TO_KNOWN_VALUE 1
#else
#define tskSET_NEW_STACKS_TO_KNOWN_VALUE 0
#endif

/*
 * Macros used by vListTask to indicate which state a task is in.
 */
// 用于指示任务任务状态 用于TaskStatus_t结构体
#define tskRUNNING_CHAR ('X')
#define tskBLOCKED_CHAR ('B')
#define tskREADY_CHAR ('R')
#define tskDELETED_CHAR ('D')
#define tskSUSPENDED_CHAR ('S')

/*
 * Some kernel aware debuggers require the data the debugger needs access to be
 * global, rather than file scope.
 */
#ifdef portREMOVE_STATIC_QUALIFIER
#define static
#endif

/* The name allocated to the Idle task.  This can be overridden by defining
configIDLE_TASK_NAME in FreeRTOSConfig.h. */
#ifndef configIDLE_TASK_NAME
#define configIDLE_TASK_NAME "IDLE"
#endif

#if (configUSE_PORT_OPTIMISED_TASK_SELECTION == 0)

// 使用通用的方式，而非特殊的cpu架构
/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
performed in a generic way that is not optimised to any particular
microcontroller architecture. */

/* uxTopReadyPriority holds the priority of the highest priority ready
state task. */
// uxTopReadyPriority是就绪任务中最高的优先级

// 记录任务最高的优先级
#define taskRECORD_READY_PRIORITY(uxPriority)  \
	{                                          \
		if ((uxPriority) > uxTopReadyPriority) \
		{                                      \
			uxTopReadyPriority = (uxPriority); \
		}                                      \
	} /* taskRECORD_READY_PRIORITY */

/*-----------------------------------------------------------*/

// 更新前优先级最高的任务，并且更新uxTopReadyPriority(就绪任务中最高的优先级)
#define taskSELECT_HIGHEST_PRIORITY_TASK()                                              \
	{                                                                                   \
		UBaseType_t uxTopPriority = uxTopReadyPriority;                                 \
                                                                                        \
		/*找到不为空的最高优先级就绪列表*/                               \
		/* Find the highest priority queue that contains ready tasks. */                \
		while (listLIST_IS_EMPTY(&(pxReadyTasksLists[uxTopPriority])))                  \
		{                                                                               \
			configASSERT(uxTopPriority);                                                \
			--uxTopPriority;                                                            \
		}                                                                               \
                                                                                        \
		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of        \
		the	same priority get an equal share of the processor time. */                  \
		/*相同优先级的任务轮训调度 更新pxCurrentTCB*/                     \
		listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &(pxReadyTasksLists[uxTopPriority])); \
		uxTopReadyPriority = uxTopPriority;                                             \
	} /* taskSELECT_HIGHEST_PRIORITY_TASK */

/*-----------------------------------------------------------*/

/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
they are only required when a port optimised method of task selection is
being used. */
// 取消定义taskRESET_READY_PRIORITY和portRESET_READY_PRIORITY
#define taskRESET_READY_PRIORITY(uxPriority)
#define portRESET_READY_PRIORITY(uxPriority, uxTopReadyPriority)

#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
performed in a way that is tailored to the particular microcontroller
architecture being used. */

/* A port optimised version is provided.  Call the port defined macros. */
#define taskRECORD_READY_PRIORITY(uxPriority) portRECORD_READY_PRIORITY(uxPriority, uxTopReadyPriority)

/*-----------------------------------------------------------*/

#define taskSELECT_HIGHEST_PRIORITY_TASK()                                              \
	{                                                                                   \
		UBaseType_t uxTopPriority;                                                      \
                                                                                        \
		/* Find the highest priority list that contains ready tasks. */                 \
		portGET_HIGHEST_PRIORITY(uxTopPriority, uxTopReadyPriority);                    \
		configASSERT(listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[uxTopPriority])) > 0); \
		listGET_OWNER_OF_NEXT_ENTRY(pxCurrentTCB, &(pxReadyTasksLists[uxTopPriority])); \
	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */

/*-----------------------------------------------------------*/

/* A port optimised version is provided, call it only if the TCB being reset
is being referenced from a ready list.  If it is referenced from a delayed
or suspended list then it won't be in a ready list. */
#define taskRESET_READY_PRIORITY(uxPriority)                                               \
	{                                                                                      \
		if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[(uxPriority)])) == (UBaseType_t)0) \
		{                                                                                  \
			portRESET_READY_PRIORITY((uxPriority), (uxTopReadyPriority));                  \
		}                                                                                  \
	}

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/*-----------------------------------------------------------*/

/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
count overflows. */
// 用于更新当前延迟列表和阻塞列表,当tickcount计数计满时
#define taskSWITCH_DELAYED_LISTS()                                                \
	{                                                                             \
		List_t *pxTemp;                                                           \
                                                                                  \
		/* The delayed tasks list should be empty when the lists are switched. */ \
		/*在切换列表的时候，延时列表应该为空*/                   \
		configASSERT((listLIST_IS_EMPTY(pxDelayedTaskList)));                     \
                                                                                  \
		pxTemp = pxDelayedTaskList;                                               \
		pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
		pxOverflowDelayedTaskList = pxTemp;                                       \
		/*翻转次数*/                                                          \
		xNumOfOverflows++;                                                        \
		/*更新下一次解除任务阻塞的时间*/                            \
		prvResetNextTaskUnblockTime();                                            \
	}

/*-----------------------------------------------------------*/

/*
 * Place the task represented by pxTCB into the appropriate ready list for
 * the task.  It is inserted at the end of the list.
 */

// 将任务加入到就绪列表
#define prvAddTaskToReadyList(pxTCB)                                                       \
	traceMOVED_TASK_TO_READY_STATE(pxTCB);                                                 \
	/*更新整个任务的最高优先级*/                                               \
	taskRECORD_READY_PRIORITY((pxTCB)->uxPriority);                                        \
	/*将tcb的状态列表加到对应优先级的就绪列表中*/                       \
	vListInsertEnd(&(pxReadyTasksLists[(pxTCB)->uxPriority]), &((pxTCB)->xStateListItem)); \
	tracePOST_MOVED_TASK_TO_READY_STATE(pxTCB)
/*-----------------------------------------------------------*/

/*
 * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 * where NULL is used to indicate that the handle of the currently executing
 * task should be used in place of the parameter.  This macro simply checks to
 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 */
// 获取tcb结构的Handle
#define prvGetTCBFromHandle(pxHandle) (((pxHandle) == NULL) ? (TCB_t *)pxCurrentTCB : (TCB_t *)(pxHandle))

/* The item value of the event list item is normally used to hold the priority
of the task to which it belongs (coded to allow it to be held in reverse
priority order).  However, it is occasionally borrowed for other purposes.  It
is important its value is not updated due to a task priority change while it is
being used for another purpose.  The following bit definition is used to inform
the scheduler that the value should not be changed - in which case it is the
responsibility of whichever module is using the value to ensure it gets set back
to its original value when it is released. */

// 用于通知调度器，认识使用该taskEVENT_LIST_ITEM_VALUE_IN_USE值的模块，在有必要的时候，需要将其复原
#if (configUSE_16_BIT_TICKS == 1)
#define taskEVENT_LIST_ITEM_VALUE_IN_USE 0x8000U
#else
#define taskEVENT_LIST_ITEM_VALUE_IN_USE 0x80000000UL
#endif

/*
 * Task control block.  A task control block (TCB) is allocated for each task,
 * and stores task state information, including a pointer to the task's context
 * (the task's run time environment, including register values)
 */
// TCB，任务控制块
typedef struct tskTaskControlBlock
{
	// 栈顶，指向任务堆栈中最后一项的位置, 这必须是TCB结构体的第一个成员(最后一个进栈的数据的指针)
	volatile StackType_t *pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */

#if (portUSING_MPU_WRAPPERS == 1)
	xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
#endif

	// 状态链表节点，用于表示该任务的状态(就绪、阻塞、挂起)
	ListItem_t xStateListItem; /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
	// 事件链表节点
	ListItem_t xEventListItem; /*< Used to reference a task from an event list. */
	// 优先级
	UBaseType_t uxPriority; /*< The priority of the task.  0 is the lowest priority. */
	// 任务栈的起始地址
	StackType_t *pxStack; /*< Points to the start of the stack. */
	// 任务的名字 debug使用
	char pcTaskName[configMAX_TASK_NAME_LEN]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

#if ((portSTACK_GROWTH > 0) || (configRECORD_STACK_HIGH_ADDRESS == 1))
	StackType_t *pxEndOfStack; /*< Points to the highest valid address for the stack. */
#endif
// 允许嵌套临界区
#if (portCRITICAL_NESTING_IN_TCB == 1)
	// 任务的嵌套深度?
	UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
#endif

#if (configUSE_TRACE_FACILITY == 1) // 计算cpu使用率
	// 储存创建任务的次数,每创建一次任务，变量会自增，debug时，用于确认任务何时被创建又何时被删除
	UBaseType_t uxTCBNumber; /*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
	// 储存一个号码用于第三方追踪
	UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */
#endif

#if (configUSE_MUTEXES == 1)
	// 任务的基础优先级(搭配继承优先级相关函数，用于解决优先级反转)
	UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
	// 任务获取的互斥信号量个数
	UBaseType_t uxMutexesHeld;
#endif

// 应用任务标签
#if (configUSE_APPLICATION_TASK_TAG == 1)
	TaskHookFunction_t pxTaskTag;
#endif

// 启用线程本地存储指针，
#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0)
	// 用于储存任务使用的，唯一的，全局变量值
	void *pvThreadLocalStoragePointers[configNUM_THREAD_LOCAL_STORAGE_POINTERS];
#endif

// 启用运行时间统计功能
#if (configGENERATE_RUN_TIME_STATS == 1)
	uint32_t ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */
#endif

// 使用newlib库 freertos不维护，也不会使用
#if (configUSE_NEWLIB_REENTRANT == 1)
	/* Allocate a Newlib reent structure that is specific to this task.
	Note Newlib support has been included by popular demand, but is not
	used by the FreeRTOS maintainers themselves.  FreeRTOS is not
	responsible for resulting newlib operation.  User must be familiar with
	newlib and must provide system-wide implementations of the necessary
	stubs. Be warned that (at the time of writing) the current newlib design
	implements a system-wide malloc() that must be provided with locks. */
	struct _reent xNewLib_reent;
#endif

// 使用任务通知功能
#if (configUSE_TASK_NOTIFICATIONS == 1)
	// 任务通知值
	volatile uint32_t ulNotifiedValue;
	// 任务通知状态
	volatile uint8_t ucNotifyState;
#endif

/* See the comments above the definition of
tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
// TCB结构体可以由静态创造
#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0) /*lint !e731 Macro has been consolidated for readability reasons. */
	uint8_t ucStaticallyAllocated;					 /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
#endif

// 允许任务延迟
#if (INCLUDE_xTaskAbortDelay == 1)
	uint8_t ucDelayAborted;
#endif

} tskTCB;

/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
below to enable the use of older kernel aware debuggers. */
typedef tskTCB TCB_t;

/*lint -save -e956 A manual analysis and inspection has been used to determine
which static variables must be declared volatile. */

// 当前运行的任务的控制块
PRIVILEGED_DATA TCB_t *volatile pxCurrentTCB = NULL;

/* Lists for ready and blocked tasks. --------------------*/
// 所有的优先级任务列表数组
PRIVILEGED_DATA static List_t pxReadyTasksLists[configMAX_PRIORITIES] = {0}; /*< Prioritised ready tasks. */
// 延时列表1和2
PRIVILEGED_DATA static List_t xDelayedTaskList1 = {0}; /*< Delayed tasks. */
PRIVILEGED_DATA static List_t xDelayedTaskList2 = {0}; /*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
// 现在使用的延时(阻塞)列表
PRIVILEGED_DATA static List_t *volatile pxDelayedTaskList = NULL; /*< Points to the delayed task list currently being used. */
// 现在使用的溢出列表
PRIVILEGED_DATA static List_t *volatile pxOverflowDelayedTaskList = NULL; /*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
// 被挂起的任务列表(不参与调度)
PRIVILEGED_DATA static List_t xPendingReadyList = {0}; /*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */

#if (INCLUDE_vTaskDelete == 1)

// 等待被终止的任务(已经被设置为删除，但是未释放内存)
PRIVILEGED_DATA static List_t xTasksWaitingTermination = {0}; /*< Tasks that have been deleted - but their memory not yet freed. */
// 等待被终止(释放内存)的任务数量
PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = (UBaseType_t)0U;

#endif

#if (INCLUDE_vTaskSuspend == 1)

// 被挂起的任务
PRIVILEGED_DATA static List_t xSuspendedTaskList = {0}; /*< Tasks that are currently suspended. */

#endif

/* Other file private variables. --------------------------------*/
// 当前的任务数
PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = (UBaseType_t)0U;
// tick 计数值
PRIVILEGED_DATA static volatile TickType_t xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
// 当前就绪任务最高权限
PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
// 调度器状态
PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
// 任务挂起期间，tick的计数次数
PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks = (UBaseType_t)0U;
// 任务状态发生改变，需要等待从新调度？
PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
// 延迟与溢出列表反转次数
PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = (BaseType_t)0;
// 用于赋值给xNewTCB->uxTCBNumber
PRIVILEGED_DATA static UBaseType_t uxTaskNumber = (UBaseType_t)0U;
// 下一个任务的解锁时刻
PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = (TickType_t)0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
// 空闲任务的句柄
PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL; /*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */

/* Context switches are held pending while the scheduler is suspended.  Also,
interrupts must not manipulate the xStateListItem of a TCB, or any of the
lists the xStateListItem can be referenced from, if the scheduler is suspended.
If an interrupt needs to unblock a task while the scheduler is suspended then it
moves the task's event list item into the xPendingReadyList, ready for the
kernel to move the task from the pending ready list into the real ready list
when the scheduler is unsuspended.  The pending ready list itself can only be
accessed from a critical section.
当调度程序暂停时，上下文切换将被挂起。 此外，如果调度程序处于暂停状态，中断不得操作
TCB 的 xStateListItem 或 xStateListItem 可以引用的任何列表。如果中断需要在调度程序
暂停时解除对任务的阻塞，那么它会将任务的事件列表项移动到 xPendingReadyList 中，以便
内核在调度程序解除暂停时将任务从挂起就绪列表移动到真正的就绪列表中。 待处理就绪列表本
身只能从关键部分访问。
*/
// 调度器状态
PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = (UBaseType_t)pdFALSE;

#if (configGENERATE_RUN_TIME_STATS == 1)

PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL; /*< Holds the value of a timer/counter the last time a task was switched in. */
PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */

#endif

/*lint -restore */

/*-----------------------------------------------------------*/

/* Callback function prototypes. --------------------------*/
// 检查task溢出的钩子函数
#if (configCHECK_FOR_STACK_OVERFLOW > 0)
extern void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName);
#endif

#if (configUSE_TICK_HOOK > 0)
extern void vApplicationTickHook(void);
#endif

// 获取空闲任务的相关信息
#if (configSUPPORT_STATIC_ALLOCATION == 1)
extern void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize);
#endif

/* File private functions. --------------------------------*/

/**
 * Utility task that simply returns pdTRUE if the task referenced by xTask is
 * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 * is in any other state.
 */

// 启用任务可以被暂停
#if (INCLUDE_vTaskSuspend == 1)

// 检查任务为什么被暂停
static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) PRIVILEGED_FUNCTION;

#endif /* INCLUDE_vTaskSuspend */

/*
 * Utility to ready all the lists used by the scheduler.  This is called
 * automatically upon the creation of the first task.
 */
// 初始化就绪链表
static void prvInitialiseTaskLists(void) PRIVILEGED_FUNCTION;

/*
 * The idle task, which as all tasks is implemented as a never ending loop.
 * The idle task is automatically created and added to the ready lists upon
 * creation of the first user task.
 *
 * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
// 空闲任务
static portTASK_FUNCTION_PROTO(prvIdleTask, pvParameters);

/*
 * Utility to free all memory allocated by the scheduler to hold a TCB,
 * including the stack pointed to by the TCB.
 *
 * This does not free memory allocated by the task itself (i.e. memory
 * allocated by calls to pvPortMalloc from within the tasks application code).
 */
#if (INCLUDE_vTaskDelete == 1)

// 删除TCB
static void prvDeleteTCB(TCB_t *pxTCB) PRIVILEGED_FUNCTION;

#endif

/*
 * Used only by the idle task.  This checks to see if anything has been placed
 * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 * and its TCB deleted.
 */
// 检查需要被删除的tcb任务，只能被空闲任务使用
static void prvCheckTasksWaitingTermination(void) PRIVILEGED_FUNCTION;

/*
 * The currently executing task is entering the Blocked state.  Add the task to
 * either the current or the overflow delayed task list.
 */
// 添加当前任务进延时列表
static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely) PRIVILEGED_FUNCTION;

/*
 * Fills an TaskStatus_t structure with information on each task that is
 * referenced from the pxList list (which may be a ready list, a delayed list,
 * a suspended list, etc.).
 *
 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 * NORMAL APPLICATION CODE.
 */
#if (configUSE_TRACE_FACILITY == 1)

// 获取pxList中的任务信息，并填充到pxTaskStatusArray
static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState) PRIVILEGED_FUNCTION;

#endif

/*
 * Searches pxList for a task with name pcNameToQuery - returning a handle to
 * the task if it is found, or NULL if the task is not found.
 */
// 允许获得任务的句柄
#if (INCLUDE_xTaskGetHandle == 1)

// 从list中获得任务的句柄，传入名字
static TCB_t *prvSearchForNameWithinSingleList(List_t *pxList, const char pcNameToQuery[]) PRIVILEGED_FUNCTION;

#endif

/*
 * When a task is created, the stack of the task is filled with a known value.
 * This function determines the 'high water mark' of the task stack by
 * determining how much of the stack remains at the original preset value.
 */
// 允许追踪和检查内存高位情况
#if ((configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))

// 检查内存占用情况
static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) PRIVILEGED_FUNCTION;

#endif

/*
 * Return the amount of time, in ticks, that will pass before the kernel will
 * next move a task from the Blocked state to the Running state.
 *
 * This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 * set to a value other than 1.
 * 以 ticks 为单位，返回内核下一次将任务从阻塞状态移至运行状态之前所需的时间。
 * 此条件编译应使用不等式 0，而非等式 1。 这是为了确保在用户定义的低功耗模式实现要求
 * 将 configUSE_TICKLESS_IDLE 设置为 1 以外的值时，可以调用 portSUPPRESS_TICKS_AND_SLEEP()。
 */
#if (configUSE_TICKLESS_IDLE != 0)

static TickType_t prvGetExpectedIdleTime(void) PRIVILEGED_FUNCTION;

#endif

/*
 * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 * will exit the Blocked state.
 //设置xNextTaskUnblockTime为下一个阻塞状态的任务将会溢出阻塞的时间
 */
static void prvResetNextTaskUnblockTime(void);

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0))

/*
 * Helper function used to pad task names with spaces when printing out
 * human readable tables of task information.
 */
// 没啥用
static char *prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName) PRIVILEGED_FUNCTION;

#endif

/*
 * Called after a Task_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 */
// 初始化新Task
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode,
								 const char *const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								 const uint32_t ulStackDepth,
								 void *const pvParameters,
								 UBaseType_t uxPriority,
								 TaskHandle_t *const pxCreatedTask,
								 TCB_t *pxNewTCB,
								 const MemoryRegion_t *const xRegions) PRIVILEGED_FUNCTION;

/*
 * Called after a new task has been created and initialised to place the task
 * under the control of the scheduler.
 */
// 把任务加到就绪列表
static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) PRIVILEGED_FUNCTION;

/*
 * freertos_tasks_c_additions_init() should only be called if the user definable
 * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 * called by the function.
 */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT

static void freertos_tasks_c_additions_init(void) PRIVILEGED_FUNCTION;

#endif

/*-----------------------------------------------------------*/

#if (configSUPPORT_STATIC_ALLOCATION == 1)

// 静态创建任务
TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,		  // 任务函数指针
							   const char *const pcName,		  // 任务的名称	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							   const uint32_t ulStackDepth,		  // 任务的栈深度
							   void *const pvParameters,		  // 任务函数的参数
							   UBaseType_t uxPriority,			  // 任务优先级
							   StackType_t *const puxStackBuffer, // 任务的静态栈地址
							   StaticTask_t *const pxTaskBuffer)  // 任务的TCB结构体
{
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

	// 检查栈和TCB是否空
	configASSERT(puxStackBuffer != NULL);
	configASSERT(pxTaskBuffer != NULL);

#if (configASSERT_DEFINED == 1)
	{
		/* Sanity check that the size of the structure used to declare a
		variable of type StaticTask_t equals the size of the real task
		structure. */
		volatile size_t xSize = sizeof(StaticTask_t);
		// 检查tcb的大小合法性
		configASSERT(xSize == sizeof(TCB_t));
	}
#endif /* configASSERT_DEFINED */

	if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL))
	{
		/* The memory used for the task's TCB and stack are passed into this
		function - use them. */
		// 将tcb指向用户传进来的tcb
		pxNewTCB = (TCB_t *)pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
		// 将任务的栈指向用户传的栈
		pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;

#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* Tasks can be created statically or dynamically, so note this
			task was created statically in case the task is later deleted. */
			// 指定TCB的分配方式
			pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
		}
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

		// 初始化任务
		prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL);
		// 添加任务到就绪列表
		prvAddNewTaskToReadyList(pxNewTCB);
	}
	else
	{
		xReturn = NULL;
	}

	return xReturn;
}

#endif /* SUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

// 使用MPU保护的情况
#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_STATIC_ALLOCATION == 1))

BaseType_t xTaskCreateRestrictedStatic(const TaskParameters_t *const pxTaskDefinition, TaskHandle_t *pxCreatedTask)
{
	TCB_t *pxNewTCB;
	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

	configASSERT(pxTaskDefinition->puxStackBuffer != NULL);
	configASSERT(pxTaskDefinition->pxTaskBuffer != NULL);

	if ((pxTaskDefinition->puxStackBuffer != NULL) && (pxTaskDefinition->pxTaskBuffer != NULL))
	{
		/* Allocate space for the TCB.  Where the memory comes from depends
		on the implementation of the port malloc function and whether or
		not static allocation is being used. */
		pxNewTCB = (TCB_t *)pxTaskDefinition->pxTaskBuffer;

		/* Store the stack location in the TCB. */
		pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0)
		{
			/* Tasks can be created statically or dynamically, so note this
			task was created statically in case the task is later deleted. */
			pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
		}
#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

		prvInitialiseNewTask(pxTaskDefinition->pvTaskCode,
							 pxTaskDefinition->pcName,
							 (uint32_t)pxTaskDefinition->usStackDepth,
							 pxTaskDefinition->pvParameters,
							 pxTaskDefinition->uxPriority,
							 pxCreatedTask, pxNewTCB,
							 pxTaskDefinition->xRegions);

		prvAddNewTaskToReadyList(pxNewTCB);
		xReturn = pdPASS;
	}

	return xReturn;
}

#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

#if ((portUSING_MPU_WRAPPERS == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

// 代有mpu保护
BaseType_t xTaskCreateRestricted(const TaskParameters_t *const pxTaskDefinition, TaskHandle_t *pxCreatedTask)
{
	TCB_t *pxNewTCB;
	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;

	configASSERT(pxTaskDefinition->puxStackBuffer);

	if (pxTaskDefinition->puxStackBuffer != NULL)
	{
		/* Allocate space for the TCB.  Where the memory comes from depends
		on the implementation of the port malloc function and whether or
		not static allocation is being used. */
		pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));

		if (pxNewTCB != NULL)
		{
			/* Store the stack location in the TCB. */
			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

#if (configSUPPORT_STATIC_ALLOCATION == 1)
			{
				/* Tasks can be created statically or dynamically, so note
				this task had a statically allocated stack in case it is
				later deleted.  The TCB was allocated dynamically. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
			}
#endif

			prvInitialiseNewTask(pxTaskDefinition->pvTaskCode,
								 pxTaskDefinition->pcName,
								 (uint32_t)pxTaskDefinition->usStackDepth,
								 pxTaskDefinition->pvParameters,
								 pxTaskDefinition->uxPriority,
								 pxCreatedTask, pxNewTCB,
								 pxTaskDefinition->xRegions);

			prvAddNewTaskToReadyList(pxNewTCB);
			xReturn = pdPASS;
		}
	}

	return xReturn;
}

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if (configSUPPORT_DYNAMIC_ALLOCATION == 1)

// 动态创建任务
BaseType_t xTaskCreate(TaskFunction_t pxTaskCode,				  /*创建任务的函数*/
					   const char *const pcName,				  /*任务别名*/
					   const configSTACK_DEPTH_TYPE usStackDepth, /*存储任务的栈深度*/
					   void *const pvParameters,				  /*参数*/
					   UBaseType_t uxPriority,					  /*优先级*/
					   TaskHandle_t *const pxCreatedTask)		  /*出参*/
{
	// 该任务的tcb结构体
	TCB_t *pxNewTCB;
	BaseType_t xReturn;

/* If the stack grows down then allocate the stack then the TCB so the stack
does not grow into the TCB.  Likewise if the stack grows up then allocate
the TCB then the stack.
如果堆栈向下生长，那么先分配任务栈再分配TCB, 这样堆栈就不会扩展到TCB中。
同样，如果堆栈向上生长，则先分配TCB再分配堆栈
 */
/*堆栈方向，低地址向高地址，向上生长*/
#if (portSTACK_GROWTH > 0)
	{
		/* Allocate space for the TCB.  Where the memory comes from depends on
		the implementation of the port malloc function and whether or not static
		allocation is being used. */
		// 为TCB分配内存空间
		pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));

		if (pxNewTCB != NULL)
		{
			/* Allocate space for the stack used by the task being created.
			The base of the stack memory stored in the TCB so the task can
			be deleted later if required. */
			// 为任务栈分配内存空间，且将tcb的pxstack指向任务栈空间
			pxNewTCB->pxStack = (StackType_t *)pvPortMalloc((((size_t)usStackDepth) * sizeof(StackType_t))); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			if (pxNewTCB->pxStack == NULL)
			{
				/* Could not allocate the stack.  Delete the allocated TCB. */
				vPortFree(pxNewTCB);
				pxNewTCB = NULL;
			}
		}
	}
#else  /* portSTACK_GROWTH 高地址向低地址生长，向下生长*/
	{
		StackType_t *pxStack;

		/*使用pvPortMalloc分配任务栈空间*/
		/* Allocate space for the stack used by the task being created. */
		pxStack = (StackType_t *)pvPortMalloc((((size_t)usStackDepth) * sizeof(StackType_t))); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

		if (pxStack != NULL)
		{
			/* Allocate space for the TCB. */
			// 分配tcb结构体空间
			pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t)); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */

			if (pxNewTCB != NULL)
			{
				/* Store the stack location in the TCB. */
				// 将tcb的pxStack地址指向为任务分配的栈空间
				pxNewTCB->pxStack = pxStack;
			}
			// pxNewTCB分配失败
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free
				it again. */
				// 释放任务堆栈空间
				vPortFree(pxStack);
			}
		}
		else
		{
			pxNewTCB = NULL;
		}
	}
#endif /* portSTACK_GROWTH */

	// TCB和任务栈分配成功
	if (pxNewTCB != NULL)
	{
// 任务即允许静态创建又允许动态
#if (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* Tasks can be created statically or dynamically, so note this
			task was created dynamically in case it is later deleted. */
			// 标识该tcb和任务堆栈是由动态创建的
			pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
		}
#endif /* configSUPPORT_STATIC_ALLOCATION */
		// 对TASK初始化(任务栈、事件listItem、状态listItem、优先级、任务的栈初始化)
		prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL);
		// 将TCB 结构体 传入到就绪链表中
		prvAddNewTaskToReadyList(pxNewTCB);
		xReturn = pdPASS;
	}
	else
	{
		// 内存不足 分配失败
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

// 初始化Task
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode,
								 const char *const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								 const uint32_t ulStackDepth,
								 void *const pvParameters,
								 UBaseType_t uxPriority,
								 TaskHandle_t *const pxCreatedTask,
								 TCB_t *pxNewTCB,
								 const MemoryRegion_t *const xRegions)
{
	StackType_t *pxTopOfStack;
	UBaseType_t x;

// 是否用MPU保护内存
#if (portUSING_MPU_WRAPPERS == 1)
	/* Should the task be created in privileged mode? */
	BaseType_t xRunPrivileged;
	if ((uxPriority & portPRIVILEGE_BIT) != 0U)
	{
		xRunPrivileged = pdTRUE;
	}
	else
	{
		xRunPrivileged = pdFALSE;
	}
	uxPriority &= ~portPRIVILEGE_BIT;
#endif /* portUSING_MPU_WRAPPERS == 1 */

/* Avoid dependency on memset() if it is not required. */
// 向分配的任务堆栈填入已知值(用于debug)
#if (tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1)
	{
		// 用于计算内存高水平线，未被访问的内存空间将会保持为0xa5u
		/* Fill the stack with a known value to assist debugging. */
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
	}
#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */

/* Calculate the top of stack address.  This depends on whether the stack
grows from high memory to low (as per the 80x86) or vice versa.
portSTACK_GROWTH is used to make the result positive or negative as required
by the port.
计算栈顶的地址，这项依赖于堆栈生长方向，portSTACK_GROWTH用于标记堆栈生成方向
*/
// 向下堆栈，不同处理器架构，会有差异
#if (portSTACK_GROWTH < 0)
	{
		// 获取栈顶地址 分配的地址减去栈深度，即可获得栈顶地址
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
		// 字节对齐，将会舍弃未对齐的内存空间。
		pxTopOfStack = (StackType_t *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK))); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */

		/* Check the alignment of the calculated top of stack is correct. */
		// 检查栈顶对齐地址是否正确
		configASSERT((((portPOINTER_SIZE_TYPE)pxTopOfStack & (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == 0UL));

#if (configRECORD_STACK_HIGH_ADDRESS == 1)
		{
			/* Also record the stack's high address, which may assist
			debugging. */
			// 记录栈顶地址，用于debug
			pxNewTCB->pxEndOfStack = pxTopOfStack;
		}
#endif /* configRECORD_STACK_HIGH_ADDRESS */
	}
#else  /* portSTACK_GROWTH 向上堆栈*/
	{
		pxTopOfStack = pxNewTCB->pxStack;

		/* Check the alignment of the stack buffer is correct. */
		// 检查分配的地址是否已经字节对齐
		configASSERT((((portPOINTER_SIZE_TYPE)pxNewTCB->pxStack & (portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK) == 0UL));

		/* The other extreme of the stack space is required if stack checking is
		performed. */
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
	}
#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	// 储存任务名到tcb结构体中
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++)
	{
		pxNewTCB->pcTaskName[x] = pcName[x];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if (pcName[x] == 0x00)
		{
			break;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	// 确保任务名字的结束，以防strlen计算任务名字长度错误
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	// 确保优先级不会溢出
	if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES)
	{
		// 重置最大优先级
		uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	// 存储TCB结构体的优先级
	pxNewTCB->uxPriority = uxPriority;
#if (configUSE_MUTEXES == 1)
	{
		// 任务的基础优先级(遗产优先级)
		pxNewTCB->uxBasePriority = uxPriority;
		// 任务的互斥信号量个数
		pxNewTCB->uxMutexesHeld = 0;
	}
#endif /* configUSE_MUTEXES */
	// 初始化listItem，将listItem所在的List设置为空
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
	vListInitialiseItem(&(pxNewTCB->xEventListItem));

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */

	// 将状态listItem的pvOwner设置为TCB结构体
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);

	/* Event lists are always in priority order. */
	// 设置事件listItem的优先级
	listSET_LIST_ITEM_VALUE(&(pxNewTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	// 设置事件listItem的pvOwner为TCB结构体
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);

// 允许临界区嵌套
#if (portCRITICAL_NESTING_IN_TCB == 1)
	{ // 嵌套计数器
		pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
	}
#endif /* portCRITICAL_NESTING_IN_TCB */

// 启用任务标签
#if (configUSE_APPLICATION_TASK_TAG == 1)
	{
		pxNewTCB->pxTaskTag = NULL;
	}
#endif /* configUSE_APPLICATION_TASK_TAG */

// 启用任务运行时间统计功能
#if (configGENERATE_RUN_TIME_STATS == 1)
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
	}
#endif /* configGENERATE_RUN_TIME_STATS */

// 使用MPU，内存保护功能
#if (portUSING_MPU_WRAPPERS == 1)
	{
		vPortStoreTaskMPUSettings(&(pxNewTCB->xMPUSettings), xRegions, pxNewTCB->pxStack, ulStackDepth);
	}
#else
	{
		/* Avoid compiler warning about unreferenced parameter. */
		(void)xRegions;
	}
#endif

// 启用线程本地储存指针
#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)
	{
		for (x = 0; x < (UBaseType_t)configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++)
		{
			pxNewTCB->pvThreadLocalStoragePointers[x] = NULL;
		}
	}
#endif

// 启用任务通知
#if (configUSE_TASK_NOTIFICATIONS == 1)
	{
		// 任务通知值
		pxNewTCB->ulNotifiedValue = 0;
		// 任务通知状态
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
	}
#endif

// 使用newlib
#if (configUSE_NEWLIB_REENTRANT == 1)
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR((&(pxNewTCB->xNewLib_reent)));
	}
#endif

// 启用任务延迟功能
#if (INCLUDE_xTaskAbortDelay == 1)
	{
		pxNewTCB->ucDelayAborted = pdFALSE;
	}
#endif

/*初始化任务堆栈，让其看起来像被调度器中断，将返回地址设置为任务函数对的起始地址，
一旦堆栈被初始化，栈顶变量将会被更新，将任务代码和tcb结构体相关联*/
/* Initialize the TCB stack to look as if the task was already running,
but had been interrupted by the scheduler.  The return address is set
to the start of the task function. Once the stack has been initialised
the top of stack variable is updated. */
#if (portUSING_MPU_WRAPPERS == 1)
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged);
	}
#else  /* portUSING_MPU_WRAPPERS */
	{
		// 初始化任务堆栈,设置寄存器的值，同时更新pxTopOfStack
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
	}
#endif /* portUSING_MPU_WRAPPERS */

	// 任务handle，指向tcb结构体
	if ((void *)pxCreatedTask != NULL)
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
/*-----------------------------------------------------------*/

// 任务添加到就绪列表
static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	// 进入代码临界区
	taskENTER_CRITICAL();
	{
		uxCurrentNumberOfTasks++;
		if (pxCurrentTCB == NULL)
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
			// 第一次将TCB结构体加入到就绪任务列表，先初始化任务相关的列表
			if (uxCurrentNumberOfTasks == (UBaseType_t)1)
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				// 初始化 就绪链表
				prvInitialiseTaskLists();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			// 优先级判断，调度器未运行时，如果当前任务优先级更高，替换成当前TCb
			if (xSchedulerRunning == pdFALSE)
			{
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority)
				{
					pxCurrentTCB = pxNewTCB;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		// Task计数加1
		uxTaskNumber++;

// 实现cpu使用追踪
#if (configUSE_TRACE_FACILITY == 1)
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE(pxNewTCB);

		// 添加task到ReadyList的最后一项
		prvAddTaskToReadyList(pxNewTCB);

		portSETUP_TCB(pxNewTCB);
	}
	// 退出代码临界保护
	taskEXIT_CRITICAL();

	// 已经启用任务调度
	if (xSchedulerRunning != pdFALSE)
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		// 新创建的任务的优先级更高
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority)
		{
			// 设置pendsv，等待任务切换
			taskYIELD_IF_USING_PREEMPTION();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelete == 1)

// 删除任务
void vTaskDelete(TaskHandle_t xTaskToDelete)
{
	TCB_t *pxTCB;

	// 关闭调度
	taskENTER_CRITICAL();
	{
		/* If null is passed in here then it is the calling task that is
		being deleted. */
		// 获取需要删除任务的句柄
		pxTCB = prvGetTCBFromHandle(xTaskToDelete);

		// 将任务从就绪列表删除
		/* Remove task from the ready list. */
		if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
		{
			taskRESET_READY_PRIORITY(pxTCB->uxPriority);
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		/* Is the task waiting on an event also? */
		// 检查任务在同时也在事件列表中
		if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
		{
			// 将其从事件列表中删除
			(void)uxListRemove(&(pxTCB->xEventListItem));
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		/* Increment the uxTaskNumber also so kernel aware debuggers can
		detect that the task lists need re-generating.  This is done before
		portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
		not return. */
		uxTaskNumber++;

		if (pxTCB == pxCurrentTCB)
		{
			/* A task is deleting itself.  This cannot complete within the
			task itself, as a context switch to another task is required.
			Place the task in the termination list.  The idle task will
			check the termination list and free up any memory allocated by
			the scheduler for the TCB and stack of the deleted task. */
			// 如果任务尝试删除自己，只能将任务插入到等待释放内存的列表，等待在空闲任务中执行
			vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxDeletedTasksWaitingCleanUp;

			/* The pre-delete hook is primarily for the Windows simulator,
			in which Windows specific clean up operations are performed,
			after which it is not possible to yield away from this task -
			hence xYieldPending is used to latch that a context switch is
			required. */
			portPRE_TASK_DELETE_HOOK(pxTCB, &xYieldPending);
		}
		else
		{
			// 减少当前的任务数量
			--uxCurrentNumberOfTasks;
			// 删除任务 ，释放内存
			prvDeleteTCB(pxTCB);

			/* Reset the next expected unblock time in case it referred to
			the task that has just been deleted. */
			// 重置下次预期解锁时间？？？
			prvResetNextTaskUnblockTime();
		}

		traceTASK_DELETE(pxTCB);
	}
	// 恢复临界区
	taskEXIT_CRITICAL();

	/* Force a reschedule if it is the currently running task that has just
	been deleted. */
	// 任务调度未运行，强制启动调用于删除任务
	if (xSchedulerRunning != pdFALSE)
	{
		if (pxTCB == pxCurrentTCB)
		{
			configASSERT(uxSchedulerSuspended == 0);
			// 发起pendsv
			portYIELD_WITHIN_API();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelayUntil == 1)

// 精确延时任务
void vTaskDelayUntil(TickType_t *const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

	// 检查最后一次解除阻塞的时间
	configASSERT(pxPreviousWakeTime);
	// 下次唤醒的时间
	configASSERT((xTimeIncrement > 0U));
	// 调度器未挂起
	configASSERT(uxSchedulerSuspended == 0);

	// 挂起所有任务，用于确保代码的原子性
	vTaskSuspendAll();
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		// 当前tick的计数值
		const TickType_t xConstTickCount = xTickCount;

		/* Generate the tick time at which the task wants to wake. */
		// 下次唤醒的时刻
		xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
		// 检查TickCount是否发生溢出
		if (xConstTickCount < *pxPreviousWakeTime)
		{
			/* The tick count has overflowed since this function was
			lasted called.  In this case the only time we should ever
			actually delay is if the wake time has also	overflowed,
			and the wake time is greater than the tick time.  When this
			is the case it is as if neither time had overflowed.*/

			// 当前tick计数已经溢出，而上次唤醒时间未溢出
			// 我们只在下次唤醒时间也溢出且大于当前tick时延时

			// 下次唤醒的时间也小于这次唤醒时间，且下次唤醒时间大于当前计数时间(在这种情况下，看起来未溢出)

			// xConstTickCount < xTimeToWake < pxPreviousWakeTime
			if ((xTimeToWake < *pxPreviousWakeTime) && (xTimeToWake > xConstTickCount))
			{
				// 进行特殊处理
				xShouldDelay = pdTRUE;
			}
			else
			{
				// 不进行处理
				mtCOVERAGE_TEST_MARKER();
			}
		}
		// tickcount未发生溢出 xConstTickCount >= *pxPreviousWakeTime
		else
		{
			/* The tick time has not overflowed.  In this case we will
			delay if either the wake time has overflowed, and/or the
			tick time is less than the wake time. */
			// 当前tick计数未溢出
			// 只在下次唤醒时间溢出或者大于当前tick时延时

			// xTimeToWake < *pxPreviousWakeTime <= xConstTickCount
			// 或 *pxPreviousWakeTime <= xConstTickCount < xTimeToWake
			if ((xTimeToWake < *pxPreviousWakeTime) || (xTimeToWake > xConstTickCount))
			{
				xShouldDelay = pdTRUE;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		/* Update the wake time ready for the next call. */
		// 更新上次唤醒时间
		*pxPreviousWakeTime = xTimeToWake;

		// 需要进行特殊处理
		if (xShouldDelay != pdFALSE)
		{
			traceTASK_DELAY_UNTIL(xTimeToWake);

			/* prvAddCurrentTaskToDelayedList() needs the block time, not
			the time to wake, so subtract the current tick count. */
			// 添加到延时列表 需要的是阻塞时间，不是唤醒时间，需要减去当前tick时间
			prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, pdFALSE);
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	// 恢复调度
	xAlreadyYielded = xTaskResumeAll();

	/* Force a reschedule if xTaskResumeAll has not already done so, we may
	have put ourselves to sleep. */
	if (xAlreadyYielded == pdFALSE)
	{
		// pendsv调度
		portYIELD_WITHIN_API();
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* INCLUDE_vTaskDelayUntil */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelay == 1)

// 普通延时
void vTaskDelay(const TickType_t xTicksToDelay)
{
	BaseType_t xAlreadyYielded = pdFALSE;

	/* A delay time of zero just forces a reschedule. */
	if (xTicksToDelay > (TickType_t)0U)
	{
		configASSERT(uxSchedulerSuspended == 0);
		// 暂停调度
		vTaskSuspendAll();
		{
			traceTASK_DELAY();

			/* A task that is removed from the event list while the
			scheduler is suspended will not get placed in the ready
			list or removed from the blocked list until the scheduler
			is resumed.

			This task cannot be in an event list as it is the currently
			executing task. */
			// 添加到延时列表
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
		}
		// 恢复调度
		xAlreadyYielded = xTaskResumeAll();
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Force a reschedule if xTaskResumeAll has not already done so, we may
	have put ourselves to sleep. */
	if (xAlreadyYielded == pdFALSE)
	{
		portYIELD_WITHIN_API();
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* INCLUDE_vTaskDelay */
/*-----------------------------------------------------------*/

#if ((INCLUDE_eTaskGetState == 1) || (configUSE_TRACE_FACILITY == 1))
// 获取任务的状态
eTaskState eTaskGetState(TaskHandle_t xTask)
{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t *const pxTCB = (TCB_t *)xTask;

	configASSERT(pxTCB);

	if (pxTCB == pxCurrentTCB)
	{
		/* The task calling this function is querying its own state. */
		eReturn = eRunning;
	}
	else
	{
		// 进入临界区
		taskENTER_CRITICAL();
		{
			// 获取到任务的xStateList
			pxStateList = (List_t *)listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
		}
		// 退出临界区
		taskEXIT_CRITICAL();

		// 在延时列表和溢出列表
		if ((pxStateList == pxDelayedTaskList) || (pxStateList == pxOverflowDelayedTaskList))
		{
			/* The task being queried is referenced from one of the Blocked
			lists. */
			eReturn = eBlocked;
		}

// 开启了阻塞
#if (INCLUDE_vTaskSuspend == 1)
		else if (pxStateList == &xSuspendedTaskList)
		{
			/* The task being queried is referenced from the suspended
			list.  Is it genuinely suspended or is it block
			indefinitely? */
			// 检查通常阻塞或者是无限期的暂停
			if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL)
			{
				eReturn = eSuspended;
			}
			else
			{
				eReturn = eBlocked;
			}
		}
#endif

#if (INCLUDE_vTaskDelete == 1)
		// 等待被删除 或者 不存在
		else if ((pxStateList == &xTasksWaitingTermination) || (pxStateList == NULL))
		{
			/* The task being queried is referenced from the deleted
			tasks list, or it is not referenced from any lists at
			all. */
			eReturn = eDeleted;
		}
#endif

		else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
		{
			/* If the task is not in any other state, it must be in the
			Ready (including pending ready) state. */
			eReturn = eReady;
		}
	}

	return eReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_eTaskGetState */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskPriorityGet == 1)

// 获取任务的权限
UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask)
{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

	taskENTER_CRITICAL();
	{
		/* If null is passed in here then it is the priority of the that
		called uxTaskPriorityGet() that is being queried. */
		pxTCB = prvGetTCBFromHandle(xTask);
		uxReturn = pxTCB->uxPriority;
	}
	taskEXIT_CRITICAL();

	return uxReturn;
}

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskPriorityGet == 1)

// 中断获取任务的权限
UBaseType_t uxTaskPriorityGetFromISR(TaskHandle_t xTask)
{
	TCB_t *pxTCB;
	UBaseType_t uxReturn, uxSavedInterruptState;

	/* RTOS ports that support interrupt nesting have the concept of a
	maximum	system call (or maximum API call) interrupt priority.
	Interrupts that are	above the maximum system call priority are keep
	permanently enabled, even when the RTOS kernel is in a critical section,
	but cannot make any calls to FreeRTOS API functions.  If configASSERT()
	is defined in FreeRTOSConfig.h then
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has
	been assigned a priority above the configured maximum system call
	priority.  Only FreeRTOS functions that end in FromISR can be called
	from interrupts	that have been assigned a priority at or (logically)
	below the maximum system call interrupt priority.  FreeRTOS maintains a
	separate interrupt safe API to ensure interrupt entry is as fast and as
	simple as possible.  More information (albeit Cortex-M specific) is
	provided on the following link:
	http://www.freertos.org/RTOS-Cortex-M3-M4.html
	支持中断嵌套的 RTOS 端口具有最大系统调用（或最大 API 调用）中断优先级的概念。
	高于最大系统调用优先级的中断将被永久启用，即使 RTOS 内核处于临界区段也是如此，
	但不能调用 FreeRTOS API 函数。 如果 configASSERT()
	则 portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 将导致断言失败，因为 FreeRTOS API
	函数是从优先级高于配置的最大系统调用优先级的中断调用的。 只有以 FromISR 结尾的
	FreeRTOS 函数才能从优先级低于最大系统调用中断优先级的中断中调用。 FreeRTOS 维护着
	一个独立的中断安全 API，以确保中断进入尽可能快速和简单。

	要想调用freertos的API，调用的函数的中断权限必须要在freertos的权限范围内,freeRTOS的
	FromISR，可能会关闭中断，不在freertos 范围内的中断权限的函数，对freertos的API调用，
	可能会对数据造成损坏，破坏了操作的原子性


	*/
	// 中断优先级检查
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	// 关闭中断
	uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* If null is passed in here then it is the priority of the calling
		task that is being queried. */
		pxTCB = prvGetTCBFromHandle(xTask);
		uxReturn = pxTCB->uxPriority;
	}
	// 设置中断
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptState);

	return uxReturn;
}

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskPrioritySet == 1)

// 设置任务的权限等级 修改权限 和 重新设置就绪列表
void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

	// 检查权限
	configASSERT((uxNewPriority < configMAX_PRIORITIES));

	// 修改权限到合法值
	/* Ensure the new priority is valid. */
	if (uxNewPriority >= (UBaseType_t)configMAX_PRIORITIES)
	{
		uxNewPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	// 进入临界区 屏蔽中断
	taskENTER_CRITICAL();
	{
		/* If null is passed in here then it is the priority of the calling
		task that is being changed. */
		// 获取句柄
		pxTCB = prvGetTCBFromHandle(xTask);

		traceTASK_PRIORITY_SET(pxTCB, uxNewPriority);

// 互斥量的优先级
#if (configUSE_MUTEXES == 1)
		{
			uxCurrentBasePriority = pxTCB->uxBasePriority;
		}
#else
		{
			uxCurrentBasePriority = pxTCB->uxPriority;
		}
#endif

		// 新的权限不等于旧的权限
		if (uxCurrentBasePriority != uxNewPriority)
		{
			/* The priority change may have readied a task of higher
			priority than the calling task. */
			// 修改任的权限可能由其他任务调用 且权限更高
			if (uxNewPriority > uxCurrentBasePriority)
			{
				// 其他任务修改权限
				if (pxTCB != pxCurrentTCB)
				{
					/* The priority of a task other than the currently
					running task is being raised.  Is the priority being
					raised above that of the running task? */
					// 新权限大于当前任务的权限 需要立即切换
					if (uxNewPriority >= pxCurrentTCB->uxPriority)
					{
						xYieldRequired = pdTRUE;
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				// 自己修改权限
				else
				{
					// 现在运行的任务权限已经是最高的了 不需要任务切换
					/* The priority of the running task is being raised,
					but the running task must already be the highest
					priority task able to run so no yield is required. */
				}
			}
			// uxNewPriority < uxCurrentBasePriority
			else if (pxTCB == pxCurrentTCB)
			{
				/* Setting the priority of the running task down means
				there may now be another task of higher priority that
				is ready to execute. */
				// 让给其他任务运行
				xYieldRequired = pdTRUE;
			}
			// uxNewPriority < uxCurrentBasePriority &&  pxTCB != pxCurrentTCB
			else
			{
				/* Setting the priority of any other task down does not
				require a yield as the running task must be above the
				new priority of the task being modified. */
				// 修改其他任务的权限 不需要进行主动切换
			}

			/* Remember the ready list the task might be referenced from
			before its uxPriority member is changed so the
			taskRESET_READY_PRIORITY() macro can function correctly. */
			// 当前任务的权限，taskRESET_READY_PRIORITY()可以恢复权限
			uxPriorityUsedOnEntry = pxTCB->uxPriority;

#if (configUSE_MUTEXES == 1)
			{
				/* Only change the priority being used if the task is not
				currently using an inherited priority. */
				// 任务的继承优先级 等于当前优先级
				if (pxTCB->uxBasePriority == pxTCB->uxPriority)
				{
					// 更改任务的优先级
					pxTCB->uxPriority = uxNewPriority;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* The base priority gets set whatever. */
				// 更新继承优先级
				pxTCB->uxBasePriority = uxNewPriority;
			}
#else
			{
				pxTCB->uxPriority = uxNewPriority;
			}
#endif

			/* Only reset the event list item value if the value is not
			being used for anything else. */
			// 时间列表的值无用
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
			{
				// 设置新值
				listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), ((TickType_t)configMAX_PRIORITIES - (TickType_t)uxNewPriority)); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task is in the blocked or suspended list we need do
			nothing more than change its priority variable. However, if
			the task is in a ready list it needs to be removed and placed
			in the list appropriate to its new priority. */
			// 检查任务是否在就绪列表
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem)) != pdFALSE)
			{
				/* The task is currently in its ready list - remove before
				adding it to it's new ready list.  As we are in a critical
				section we can do this even if the scheduler is suspended. */
				// 从旧的移除
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
				{
					/* It is known that the task is in its ready list so
					there is no need to check again and the port level
					reset macro can be called directly. */
					portRESET_READY_PRIORITY(uxPriorityUsedOnEntry, uxTopReadyPriority);
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				// 加入新的
				prvAddTaskToReadyList(pxTCB);
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if (xYieldRequired != pdFALSE)
			{
				// pendsv 切换任务
				taskYIELD_IF_USING_PREEMPTION();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Remove compiler warning about unused variables when the port
			optimised task selection is not being used. */
			(void)uxPriorityUsedOnEntry;
		}
	}
	// 退出临界区 开启中断
	taskEXIT_CRITICAL();
}

#endif /* INCLUDE_vTaskPrioritySet */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

// 阻塞任务
void vTaskSuspend(TaskHandle_t xTaskToSuspend)
{
	TCB_t *pxTCB;

	// 进入临界区 关闭中断
	taskENTER_CRITICAL();
	{
		/* If null is passed in here then it is the running task that is
		being suspended. */
		// 任务的句柄
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);

		traceTASK_SUSPEND(pxTCB);

		/* Remove task from the ready/delayed list and place in the
		suspended list. */
		// 移除就绪列表
		if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
		{
			taskRESET_READY_PRIORITY(pxTCB->uxPriority);
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		/* Is the task waiting on an event also? */
		// 检查事件列表
		if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
		{
			// 从事件列表移除
			(void)uxListRemove(&(pxTCB->xEventListItem));
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		// 插入到暂停的列表中
		vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));

// 启用了任务通知功能
#if (configUSE_TASK_NOTIFICATIONS == 1)
		{
			if (pxTCB->ucNotifyState == taskWAITING_NOTIFICATION)
			{
				/* The task was blocked to wait for a notification, but is
				now suspended, so no notification was received. */
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
			}
		}
#endif
	}
	// 退出临界区
	taskEXIT_CRITICAL();

	// 调度器运行
	if (xSchedulerRunning != pdFALSE)
	{
		/* Reset the next expected unblock time in case it referred to the
		task that is now in the Suspended state. */
		taskENTER_CRITICAL();
		{
			// 设置下次运行时间
			prvResetNextTaskUnblockTime();
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	// 需要阻塞的是自己
	if (pxTCB == pxCurrentTCB)
	{
		if (xSchedulerRunning != pdFALSE)
		{
			/* The current task has just been suspended. */
			configASSERT(uxSchedulerSuspended == 0);
			// 设置pendsv
			portYIELD_WITHIN_API();
		}
		// 调度器没有运行
		else
		{
			/* The scheduler is not running, but the task that was pointed
			to by pxCurrentTCB has just been suspended and pxCurrentTCB
			must be adjusted to point to a different task. */
			if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == uxCurrentNumberOfTasks)
			{
				/* No other tasks are ready, so set pxCurrentTCB back to
				NULL so when the next task is created pxCurrentTCB will
				be set to point to it no matter what its relative priority
				is. */
				pxCurrentTCB = NULL;
			}
			else
			{
				// 更新tcb
				vTaskSwitchContext();
			}
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

// 如果任务处于挂起(暂停)列表中、和不在挂起等待列表中和任务不等待任何事件，则返回pdTRUE
static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask)
{
	BaseType_t xReturn = pdFALSE;
	const TCB_t *const pxTCB = (TCB_t *)xTask;

	/* Accesses xPendingReadyList so must be called from a critical
	section. */

	/* It does not make sense to check if the calling task is suspended. */
	configASSERT(xTask);

	/* Is the task being resumed actually in the suspended list? */
	// 检查任务是否早已进入暂停列表(在xSuspendedTaskList)
	if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE)
	{
		// 检查任务是否已经被isr恢复，暂时进入了xPendingReadyListlist(不在xPendingReadyList)
		/* Has the task already been resumed from within an ISR? */
		if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) == pdFALSE)
		{
			/* Is it in the suspended list because it is in the	Suspended
			state, or because is is blocked with no timeout? */
			// 检查在suspended是因为在阻塞态或是无期限延迟(未等待任何事件)
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) != pdFALSE) /*lint !e961.  The cast is only redundant when NULL is used. */
			{
				xReturn = pdTRUE;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskSuspend == 1)

// 恢复任务

void vTaskResume(TaskHandle_t xTaskToResume)
{
	TCB_t *const pxTCB = (TCB_t *)xTaskToResume;

	/* It does not make sense to resume the calling task. */
	configASSERT(xTaskToResume);

	/* The parameter cannot be NULL as it is impossible to resume the
	currently executing task. */

	// 需要恢复的任务不是当前任务
	if ((pxTCB != NULL) && (pxTCB != pxCurrentTCB))
	{
		// 进入临界区 关中断
		taskENTER_CRITICAL();
		{
			// 任务在阻塞中
			if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)
			{
				traceTASK_RESUME(pxTCB);

				/* The ready list can be accessed even if the scheduler is
				suspended because this is inside a critical section. */
				// 从xSuspendedTaskList移除
				(void)uxListRemove(&(pxTCB->xStateListItem));
				// 加入到就绪列表
				prvAddTaskToReadyList(pxTCB);

				/* A higher priority task may have just been resumed. */
				if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
				{
					/* This yield may not cause the task just resumed to run,
					but will leave the lists in the correct state for the
					next yield. */
					// 恢复的任务权限更高 抢占式
					taskYIELD_IF_USING_PREEMPTION();
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		// 退出临界区
		taskEXIT_CRITICAL();
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* INCLUDE_vTaskSuspend */

/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskResumeFromISR == 1) && (INCLUDE_vTaskSuspend == 1))

// 中断恢复任务
BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume)
{
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t *const pxTCB = (TCB_t *)xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

	configASSERT(xTaskToResume);

	/* RTOS ports that support interrupt nesting have the concept of a
	maximum	system call (or maximum API call) interrupt priority.
	Interrupts that are	above the maximum system call priority are keep
	permanently enabled, even when the RTOS kernel is in a critical section,
	but cannot make any calls to FreeRTOS API functions.  If configASSERT()
	is defined in FreeRTOSConfig.h then
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has
	been assigned a priority above the configured maximum system call
	priority.  Only FreeRTOS functions that end in FromISR can be called
	from interrupts	that have been assigned a priority at or (logically)
	below the maximum system call interrupt priority.  FreeRTOS maintains a
	separate interrupt safe API to ensure interrupt entry is as fast and as
	simple as possible.  More information (albeit Cortex-M specific) is
	provided on the following link:
	http://www.freertos.org/RTOS-Cortex-M3-M4.html */

	// 检查当前优先级
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	// 关闭中断
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		// 检查任务满足回复的要求不
		if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE)
		{
			traceTASK_RESUME_FROM_ISR(pxTCB);

			/* Check the ready lists can be accessed. */
			// 调度器运行
			if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
			{
				/* Ready lists can be accessed so move the task from the
				suspended list to the ready list directly. */
				// 需要进行任务切换
				if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
				{
					xYieldRequired = pdTRUE;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				// 删除从suspendlist
				(void)uxListRemove(&(pxTCB->xStateListItem));
				// 加入就绪列表
				prvAddTaskToReadyList(pxTCB);
			}
			else
			{
				/* The delayed or ready lists cannot be accessed so the task
				is held in the pending ready list until the scheduler is
				unsuspended. */
				// 调度器未运行 插入到xPendingReadyList
				vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

	return xYieldRequired;
}

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/
// 开始任务调度器
void vTaskStartScheduler(void)
{
	BaseType_t xReturn;

/* Add the idle task at the lowest priority. */
// 添加空闲任务在最低优先级中
#if (configSUPPORT_STATIC_ALLOCATION == 1)
	{
		// 空闲任务TCB内存
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
		// 空闲任务代码块栈内存
		StackType_t *pxIdleTaskStackBuffer = NULL;
		// 栈大小
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		// 指向tcb地址和任务块栈内存地址
		vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize);
		// 静态创建 空闲内存任务
		xIdleTaskHandle = xTaskCreateStatic(prvIdleTask,
											configIDLE_TASK_NAME,
											ulIdleTaskStackSize,
											(void *)NULL, /*lint !e961.  The cast is not redundant for all compilers. */
											(tskIDLE_PRIORITY | portPRIVILEGE_BIT),
											pxIdleTaskStackBuffer,
											pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if (xIdleTaskHandle != NULL)
		{
			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
		}
	}
#else
	{
		// 动态创建空闲任务
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(prvIdleTask,
							  configIDLE_TASK_NAME,
							  configMINIMAL_STACK_SIZE,
							  (void *)NULL,
							  (tskIDLE_PRIORITY | portPRIVILEGE_BIT),
							  &xIdleTaskHandle); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
#endif /* configSUPPORT_STATIC_ALLOCATION */

// 使用软件定时器
#if (configUSE_TIMERS == 1)
	{
		if (xReturn == pdPASS)
		{
			xReturn = xTimerCreateTimerTask();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_TIMERS */

	if (xReturn == pdPASS)
	{
/* freertos_tasks_c_additions_init() should only be called if the user
definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
the only macro called by the function. */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
		{
			freertos_tasks_c_additions_init();
		}
#endif

		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		/*在此处屏蔽中断，确保tick没有在调用完成xPortStartScheduler()之前发生
		,已经创建的任务堆栈包括一个中断打开的状态字,因此在启用第一个任务的时,中
		断将会自动重开启*/
		portDISABLE_INTERRUPTS();

#if (configUSE_NEWLIB_REENTRANT == 1)
		{
			/* Switch Newlib's _impure_ptr variable to point to the _reent
			structure specific to the task that will run first. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
		xSchedulerRunning = pdTRUE;
		xTickCount = (TickType_t)0U;

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
		is set to 0 and the following line fails to build then ensure you do not
		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
		FreeRTOSConfig.h file. */
		/*如果定义了configGENERATE_RUN_TIME_STATS,那么以下的宏必须被定义去配置定时器
		/计数器,用于生成运行时计数时基。如果configGENERATE_RUN_TIME_STATS被设置为0,那
		以下的将会无法编译,确保未定义portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()在config.h*/
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		// 定时器tick的设定是和硬件相关，因此需要可移植接口
		if (xPortStartScheduler() != pdFALSE)
		{
			/* Should not reach here as if the scheduler is running the
			function will not return. */
		}
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	(void)xIdleTaskHandle;
}
/*-----------------------------------------------------------*/

// 结束freertos内核 仅仅在 x86上实现
void vTaskEndScheduler(void)
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	// 关闭中断
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

// 挂起调度器 阻止上下文切换
void vTaskSuspendAll(void)
{
	// 临界区不是必须，因为变量的类型是BaseType_t
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	// 挂起调度器
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

#if (configUSE_TICKLESS_IDLE != 0)

// 获取cpu进入低功耗模式的时长
static TickType_t prvGetExpectedIdleTime(void)
{
	TickType_t xReturn;
	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;

/* uxHigherPriorityReadyTasks takes care of the case where
configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
task that are in the Ready state, even though the idle task is
running. */
#if (configUSE_PORT_OPTIMISED_TASK_SELECTION == 0)
	{
		if (uxTopReadyPriority > tskIDLE_PRIORITY)
		{
			uxHigherPriorityReadyTasks = pdTRUE;
		}
	}
#else
	{
		const UBaseType_t uxLeastSignificantBit = (UBaseType_t)0x01;

		/* When port optimised task selection is used the uxTopReadyPriority
		variable is used as a bit map.  If bits other than the least
		significant bit are set then there are tasks that have a priority
		above the idle priority that are in the Ready state.  This takes
		care of the case where the co-operative scheduler is in use. */
		if (uxTopReadyPriority > uxLeastSignificantBit)
		{
			uxHigherPriorityReadyTasks = pdTRUE;
		}
	}
#endif

	if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY)
	{
		xReturn = 0;
	}
	else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > 1)
	{
		/* There are other idle priority tasks in the ready state.  If
		time slicing is used then the very next tick interrupt must be
		processed. */
		xReturn = 0;
	}
	else if (uxHigherPriorityReadyTasks != pdFALSE)
	{
		/* There are tasks in the Ready state that have a priority above the
		idle priority.  This path can only be reached if
		configUSE_PREEMPTION is 0. */
		xReturn = 0;
	}
	else
	{
		xReturn = xNextTaskUnblockTime - xTickCount;
	}

	return xReturn;
}

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

// 恢复调度
BaseType_t xTaskResumeAll(void)
{
	TCB_t *pxTCB = NULL;
	BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	// 当uxSchedulerSuspended为0时,不满足在调用xTaskResumeAll之前先调用了vTaskSuspendAll()
	configASSERT(uxSchedulerSuspended);

	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */

	// 进入临界区
	taskENTER_CRITICAL();
	{
		--uxSchedulerSuspended;

		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
		{
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U)
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				// 当阻塞列表不为空时
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE)
				{
					// 从xPendingReadyList读取出tcb
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
					// 从事件和状态列表移除
					(void)uxListRemove(&(pxTCB->xEventListItem));
					(void)uxListRemove(&(pxTCB->xStateListItem));
					// 添加到就绪列表
					prvAddTaskToReadyList(pxTCB);

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					// 释放的任务优先级更高，需要从新调度
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
					{
						xYieldPending = pdTRUE;
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if (pxTCB != NULL)
				{
					/* A task was unblocked while the scheduler was suspended,
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					// 重置解除阻塞的时间
					prvResetNextTaskUnblockTime();
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time.
				如果在调度程序暂停时出现了ticks，则应立即进行处理。 这样可确保tick计数
				不会错过，并在正确的时间恢复任何延迟的任务。 */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */

					// 暂停时间也有计数
					if (uxPendedCounts > (UBaseType_t)0U)
					{
						do
						{
							// 手动补偿tick count
							if (xTaskIncrementTick() != pdFALSE)
							{
								xYieldPending = pdTRUE;
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
						} while (uxPendedCounts > (UBaseType_t)0U);

						uxPendedTicks = 0;
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				// 需要进行任务切换 pendsv
				if (xYieldPending != pdFALSE)
				{
#if (configUSE_PREEMPTION != 0)
					{
						xAlreadyYielded = pdTRUE;
					}
#endif
					taskYIELD_IF_USING_PREEMPTION();
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	// 退出临界区
	taskEXIT_CRITICAL();

	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

// 获取计数值
TickType_t xTaskGetTickCount(void)
{
	TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
}
/*-----------------------------------------------------------*/

// 中断获取计数值
TickType_t xTaskGetTickCountFromISR(void)
{
	TickType_t xReturn;
	UBaseType_t uxSavedInterruptStatus;

	/* RTOS ports that support interrupt nesting have the concept of a maximum
	system call (or maximum API call) interrupt priority.  Interrupts that are
	above the maximum system call priority are kept permanently enabled, even
	when the RTOS kernel is in a critical section, but cannot make any calls to
	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has been
	assigned a priority above the configured maximum system call priority.
	Only FreeRTOS functions that end in FromISR can be called from interrupts
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

	return xReturn;
}
/*-----------------------------------------------------------*/

// 获取任务的时长
UBaseType_t uxTaskGetNumberOfTasks(void)
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
}
/*-----------------------------------------------------------*/

// 获取任务的名字
char *pcTaskGetName(TaskHandle_t xTaskToQuery) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle(xTaskToQuery);
	configASSERT(pxTCB);
	return &(pxTCB->pcTaskName[0]);
}
/*-----------------------------------------------------------*/

#if (INCLUDE_xTaskGetHandle == 1)

// 从list中找到符合名字的tcb
static TCB_t *prvSearchForNameWithinSingleList(List_t *pxList, const char pcNameToQuery[])
{
	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
	UBaseType_t x;
	char cNextChar;

	/* This function is called with the scheduler suspended. */

	// list长度必须不为0
	if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0)
	{
		// 从pxList取出来的第一个tcb
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);

		do
		{
			// 从pxList取出tcb
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);

			/* Check each character in the name looking for a match or
			mismatch. */
			// 从tcb中到到同样名字的tcb
			for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++)
			{
				cNextChar = pxNextTCB->pcTaskName[x];

				// 不匹配
				if (cNextChar != pcNameToQuery[x])
				{
					/* Characters didn't match. */
					break;
				}
				// 匹配且找到的名字的尾
				else if (cNextChar == 0x00)
				{
					/* Both strings terminated, a match must have been
					found. */
					pxReturn = pxNextTCB;
					break;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			if (pxReturn != NULL)
			{
				/* The handle has been found. */
				break;
			}

		} while (pxNextTCB != pxFirstTCB);
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return pxReturn;
}

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

#if (INCLUDE_xTaskGetHandle == 1)

// 通过名字获取到任务的句柄
TaskHandle_t xTaskGetHandle(const char *pcNameToQuery) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	UBaseType_t uxQueue = configMAX_PRIORITIES;
	TCB_t *pxTCB;

	/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
	configASSERT(strlen(pcNameToQuery) < configMAX_TASK_NAME_LEN);

	vTaskSuspendAll();
	{
		/* Search the ready lists. */
		do
		{
			uxQueue--;
			pxTCB = prvSearchForNameWithinSingleList((List_t *)&(pxReadyTasksLists[uxQueue]), pcNameToQuery);

			if (pxTCB != NULL)
			{
				/* Found the handle. */
				break;
			}

		} while (uxQueue > (UBaseType_t)tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

		/* Search the delayed lists. */
		if (pxTCB == NULL)
		{
			pxTCB = prvSearchForNameWithinSingleList((List_t *)pxDelayedTaskList, pcNameToQuery);
		}

		if (pxTCB == NULL)
		{
			pxTCB = prvSearchForNameWithinSingleList((List_t *)pxOverflowDelayedTaskList, pcNameToQuery);
		}

#if (INCLUDE_vTaskSuspend == 1)
		{
			if (pxTCB == NULL)
			{
				/* Search the suspended list. */
				pxTCB = prvSearchForNameWithinSingleList(&xSuspendedTaskList, pcNameToQuery);
			}
		}
#endif

#if (INCLUDE_vTaskDelete == 1)
		{
			if (pxTCB == NULL)
			{
				/* Search the deleted list. */
				pxTCB = prvSearchForNameWithinSingleList(&xTasksWaitingTermination, pcNameToQuery);
			}
		}
#endif
	}
	(void)xTaskResumeAll();

	return (TaskHandle_t)pxTCB;
}

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

// 获得系统状态
UBaseType_t uxTaskGetSystemState(TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)
{
	// 就绪任务列表的个数
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

	// 暂缓调度
	vTaskSuspendAll();
	{
		/* Is there a space in the array for each task in the system? */
		if (uxArraySize >= uxCurrentNumberOfTasks)
		{
			/* Fill in an TaskStatus_t structure with information on each
			task in the Ready state. */
			do
			{
				uxQueue--;
				// 从就绪任务列表中读取出pxTaskStatus，并且填充到pxTaskStatusArray中
				uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &(pxReadyTasksLists[uxQueue]), eReady);

			} while (uxQueue > (UBaseType_t)tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			/* Fill in an TaskStatus_t structure with information on each
			task in the Blocked state. */
			// 读取延时列表和溢出列表
			uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxDelayedTaskList, eBlocked);
			uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxOverflowDelayedTaskList, eBlocked);

#if (INCLUDE_vTaskDelete == 1)
			{
				/* Fill in an TaskStatus_t structure with information on
				each task that has been deleted but not yet cleaned up. */
				// 读取等待删除列表
				uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xTasksWaitingTermination, eDeleted);
			}
#endif

#if (INCLUDE_vTaskSuspend == 1)
			{
				/* Fill in an TaskStatus_t structure with information on
				each task in the Suspended state. */
				// 读取等待终止的列表
				uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xSuspendedTaskList, eSuspended);
			}
#endif

#if (configGENERATE_RUN_TIME_STATS == 1)
			{
				// 获取到任务所有的运行时间
				if (pulTotalRunTime != NULL)
				{
#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE((*pulTotalRunTime));
#else
					*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
#endif
				}
			}
#else
			{
				if (pulTotalRunTime != NULL)
				{
					*pulTotalRunTime = 0;
				}
			}
#endif
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	(void)xTaskResumeAll();

	return uxTask;
}

#endif /* configUSE_TRACE_FACILITY */
/*----------------------------------------------------------*/

#if (INCLUDE_xTaskGetIdleTaskHandle == 1)

TaskHandle_t xTaskGetIdleTaskHandle(void)
{
	/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
	started, then xIdleTaskHandle will be NULL. */
	configASSERT((xIdleTaskHandle != NULL));
	return xIdleTaskHandle;
}

#endif /* INCLUDE_xTaskGetIdleTaskHandle */
/*----------------------------------------------------------*/

/* This conditional compilation should use inequality to 0, not equality to 1.
This is to ensure vTaskStepTick() is available when user defined low power mode
implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1. */
#if (configUSE_TICKLESS_IDLE != 0)

void vTaskStepTick(const TickType_t xTicksToJump)
{
	/* Correct the tick count value after a period during which the tick
	was suppressed.  Note this does *not* call the tick hook function for
	each stepped tick. */
	configASSERT((xTickCount + xTicksToJump) <= xNextTaskUnblockTime);
	xTickCount += xTicksToJump;
	traceINCREASE_TICK_COUNT(xTicksToJump);
}

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

#if (INCLUDE_xTaskAbortDelay == 1)

BaseType_t xTaskAbortDelay(TaskHandle_t xTask)
{
	TCB_t *pxTCB = (TCB_t *)xTask;
	BaseType_t xReturn;

	configASSERT(pxTCB);

	vTaskSuspendAll();
	{
		/* A task can only be prematurely removed from the Blocked state if
		it is actually in the Blocked state. */
		if (eTaskGetState(xTask) == eBlocked)
		{
			xReturn = pdPASS;

			/* Remove the reference to the task from the blocked list.  An
			interrupt won't touch the xStateListItem because the
			scheduler is suspended. */
			(void)uxListRemove(&(pxTCB->xStateListItem));

			/* Is the task waiting on an event also?  If so remove it from
			the event list too.  Interrupts can touch the event list item,
			even though the scheduler is suspended, so a critical section
			is used. */
			taskENTER_CRITICAL();
			{
				if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
				{
					(void)uxListRemove(&(pxTCB->xEventListItem));
					pxTCB->ucDelayAborted = pdTRUE;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();

			/* Place the unblocked task into the appropriate ready list. */
			prvAddTaskToReadyList(pxTCB);

/* A task being unblocked cannot cause an immediate context
switch if preemption is turned off. */
#if (configUSE_PREEMPTION == 1)
			{
				/* Preemption is on, but a context switch should only be
				performed if the unblocked task has a priority that is
				equal to or higher than the currently executing task. */
				if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
				{
					/* Pend the yield to be performed when the scheduler
					is unsuspended. */
					xYieldPending = pdTRUE;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
#endif /* configUSE_PREEMPTION */
		}
		else
		{
			xReturn = pdFAIL;
		}
	}
	(void)xTaskResumeAll();

	return xReturn;
}

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick(void)
{
	TCB_t *pxTCB;
	TickType_t xItemValue;
	BaseType_t xSwitchRequired = pdFALSE;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked.
	由可移值层调用当每一次tick中断发生的时候，增加tick然后检查tick是否会导致任何任务被解锁 */
	traceTASK_INCREMENT_TICK(xTickCount);

	// 检查是否暂缓调度
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. 小幅度优化，在代码块中tick计数不能变*/
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. 增加RTOS tick，当tick计数溢出为0时，切换延时和溢出列表*/
		xTickCount = xConstTickCount;

		if (xConstTickCount == (TickType_t)0U) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
		{
			// 交换延时列表和溢出列表
			taskSWITCH_DELAYED_LISTS();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list.
		检查tick是否造超过了等待任务解锁时间，任务储存在队列中按照他们的唤醒时间排序，
		一旦找到了某个任务的阻塞时间还没有超时，就没有必要继续在队列中寻找其他任务
		*/
		if (xConstTickCount >= xNextTaskUnblockTime)
		{
			for (;;)
			{
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE)
				{
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through.
					如果延迟列表空，设置xNextTaskUnblockTime为最大时间，这样
					if( xTickCount >= xNextTaskUnblockTime )就不会通过*/
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					break;
				}
				else
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state.
					如果延迟列表不为空，获取延迟列表的第一个项，这就是下次从阻塞
					状态移除的时间
					*/

					// 获取延迟列表的头节点
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
					// 获取到延迟列表的值
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));

					if (xConstTickCount < xItemValue)
					{
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime.
						如果还未到解锁项目的时间，但获取到延迟列表的值必须从阻塞
						状态移除，因此记录获取到延迟列表的值在下次解锁时间
						*/
						xNextTaskUnblockTime = xItemValue;
						break;
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					// 将任务从状态列表移除
					/* It is time to remove the item from the Blocked state. */
					(void)uxListRemove(&(pxTCB->xStateListItem));

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					// 任务还在等待某个事件，也将其移除
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
					{
						(void)uxListRemove(&(pxTCB->xEventListItem));
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					// 将已经解锁的任务放在就绪列表
					prvAddTaskToReadyList(pxTCB);

/* A task being unblocked cannot cause an immediate
context switch if preemption is turned off.
一个任务被解锁时，不能造成一个立即的任务切换，如果优先级抢占被关闭 */
#if (configUSE_PREEMPTION == 1)
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task.
						优先级抢占被开启，上下文切换需要任务的优先级更高或者相同*/
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority)
						{
							xSwitchRequired = pdTRUE;
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
#endif /* configUSE_PREEMPTION */
				}
			}
		}

/* Tasks of equal priority to the currently running task will share
processing time (time slice) if preemption is on, and the application
writer has not explicitly turned time slicing off.
如果抢占优先级开启，且开发者没有明确的关闭时间片调度，任务优先级相同的任务，
将会共享运行时间(时间片轮转)*/

// 开启抢占优先级和开启时间片轮转
#if ((configUSE_PREEMPTION == 1) && (configUSE_TIME_SLICING == 1))
		{
			// 当前优先级的就绪列表长度大于1，开启任务切换
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1)
			{
				xSwitchRequired = pdTRUE;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */

#if (configUSE_TICK_HOOK == 1)
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if (uxPendedTicks == (UBaseType_t)0U)
			{
				vApplicationTickHook();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_TICK_HOOK */
	}
	// 开启了暂缓调度
	else
	{
		// 增加暂缓时间
		++uxPendedTicks;

/* The tick hook gets called at regular intervals, even if the
scheduler is locked. */
#if (configUSE_TICK_HOOK == 1)
		{
			vApplicationTickHook();
		}
#endif
	}

// 优先级抢占
#if (configUSE_PREEMPTION == 1)
	{
		if (xYieldPending != pdFALSE)
		{
			xSwitchRequired = pdTRUE;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)

// 设置应用的hook标签
void vTaskSetApplicationTaskTag(TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
	TCB_t *xTCB;

	/* If xTask is NULL then it is the task hook of the calling task that is
	getting set. */
	if (xTask == NULL)
	{
		xTCB = (TCB_t *)pxCurrentTCB;
	}
	else
	{
		xTCB = (TCB_t *)xTask;
	}

	/* Save the hook function in the TCB.  A critical section is required as
	the value can be accessed from an interrupt. */
	taskENTER_CRITICAL();
	xTCB->pxTaskTag = pxHookFunction;
	taskEXIT_CRITICAL();
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)
// 获取应用的hook标签
TaskHookFunction_t xTaskGetApplicationTaskTag(TaskHandle_t xTask)
{
	TCB_t *xTCB;
	TaskHookFunction_t xReturn;

	/* If xTask is NULL then we are setting our own task hook. */
	if (xTask == NULL)
	{
		xTCB = (TCB_t *)pxCurrentTCB;
	}
	else
	{
		xTCB = (TCB_t *)xTask;
	}

	/* Save the hook function in the TCB.  A critical section is required as
	the value can be accessed from an interrupt. */
	taskENTER_CRITICAL();
	{
		xReturn = xTCB->pxTaskTag;
	}
	taskEXIT_CRITICAL();

	return xReturn;
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if (configUSE_APPLICATION_TASK_TAG == 1)
// 执行应用的hook标签
BaseType_t xTaskCallApplicationTaskHook(TaskHandle_t xTask, void *pvParameter)
{
	TCB_t *xTCB;
	BaseType_t xReturn;

	/* If xTask is NULL then we are calling our own task hook. */
	if (xTask == NULL)
	{
		xTCB = (TCB_t *)pxCurrentTCB;
	}
	else
	{
		xTCB = (TCB_t *)xTask;
	}

	if (xTCB->pxTaskTag != NULL)
	{
		xReturn = xTCB->pxTaskTag(pvParameter);
	}
	else
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/
// 切换current TCb
void vTaskSwitchContext(void)
{
	// 调度是否在运行
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE)
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
		traceTASK_SWITCHED_OUT();

#if (configGENERATE_RUN_TIME_STATS == 1)
		{
#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
			portALT_GET_RUN_TIME_COUNTER_VALUE(ulTotalRunTime);
#else
			ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
#endif

			/* Add the amount of time the task has been running to the
			accumulated time so far.  The time the task started running was
			stored in ulTaskSwitchedInTime.  Note that there is no overflow
			protection here so count values are only valid until the timer
			overflows.  The guard against negative values is to protect
			against suspect run time stat counter implementations - which
			are provided by the application, not the kernel. */
			if (ulTotalRunTime > ulTaskSwitchedInTime)
			{
				pxCurrentTCB->ulRunTimeCounter += (ulTotalRunTime - ulTaskSwitchedInTime);
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
#endif /* configGENERATE_RUN_TIME_STATS */

		// 检查栈溢出
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		// 更新pxCurrentTCB
		taskSELECT_HIGHEST_PRIORITY_TASK();
		traceTASK_SWITCHED_IN();

#if (configUSE_NEWLIB_REENTRANT == 1)
		{
			/* Switch Newlib's _impure_ptr variable to point to the _reent
			structure specific to this task. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
/*-----------------------------------------------------------*/
// 将任务放在事件列表中
void vTaskPlaceOnEventList(List_t *const pxEventList, const TickType_t xTicksToWait)
{
	configASSERT(pxEventList);

	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED.
	调用该函数时，必须禁用中断或暂停调度程序，并锁定正在访问的队列。*/

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts.
	将 TCB 的事件列表项放入相应的事件列表中。
	该项目按优先级顺序放入列表，这样优先级最高的任务最先被事件唤醒。
	包含事件列表的队列	列表的队列被锁定，以防止中断同时访问 */
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));

	// 添加到延时列表
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
}
/*-----------------------------------------------------------*/
// 将任务放在无序事件列表
void vTaskPlaceOnUnorderedEventList(List_t *pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
	configASSERT(pxEventList);

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	// 调用该函数，必须暂停调度。函数由事件组实施所使用
	configASSERT(uxSchedulerSuspended != 0);

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	// 储存数值到事件列表项，中断不会访问不在阻塞状态的任务
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE);

	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	// 将tcb的事件列表项放合适的事件列表
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));

	// 加入延时列表
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
}
/*-----------------------------------------------------------*/

#if (configUSE_TIMERS == 1)

// 将任务放在受限制的事件列表
void vTaskPlaceOnEventListRestricted(List_t *const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
	configASSERT(pxEventList);

	// 该函数不应该被用户代码调用，因为该函数是受限制的，不是通用的api，调用
	// 该函数有特殊的需求，应该有任务暂缓的时候调用
	/* This function should not be called by application code hence the
	'Restricted' in its name.  It is not part of the public API.  It is
	designed for use by kernel code, and has special calling requirements -
	it should be called with the scheduler suspended. */

	// 假设这是唯一的在等待的任务在事件列表中，使用vListInsertEnd代替。
	/* Place the event list item of the TCB in the appropriate event list.
	In this case it is assume that this is the only task that is going to
	be waiting on this event list, so the faster vListInsertEnd() function
	can be used in place of vListInsert. */
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));

	/* If the task should block indefinitely then set the block time to a
	value that will be recognised as an indefinite delay inside the
	prvAddCurrentTaskToDelayedList() function. */
	// 无期限的阻塞
	if (xWaitIndefinitely != pdFALSE)
	{
		xTicksToWait = portMAX_DELAY;
	}

	traceTASK_DELAY_UNTIL((xTickCount + xTicksToWait));
	// 添加到延时列表
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
}

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

// 从事件列表移除
BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList)
{
	TCB_t *pxUnblockedTCB;
	BaseType_t xReturn;

	// 临界区调用,或者isr调用
	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
	called from a critical section within an ISR. */

	// 事件列表按照优先级排列，第一个的优先级是最高的
	/* The event list is sorted in priority order, so the first in the list can
	be removed as it is known to be the highest priority.  Remove the TCB from
	the delayed list, and add it to the ready list.

	//如果一个事件的队列已经被锁定，那么该功能将永远不会调用，队列的锁定数将会被修改，
	这意味着对事件的访问会有独占权
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	// 假设已经确保过pxEventList不为空
	// 从事件列表中读取tcb
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
	configASSERT(pxUnblockedTCB);
	// 将tcb 从事件列表移除
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));

	// 调度器在运行
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
	{
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
		prvAddTaskToReadyList(pxUnblockedTCB);
	}
	else
	// 调度器未运行
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
	}

	// 需要释放的优先级检查
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority)
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		// 让调用的任务知道 自己应该释放cpu
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xReturn = pdFALSE;
	}

#if (configUSE_TICKLESS_IDLE != 0)
	{
		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
		might be set to the blocked task's time out time.  If the task is
		unblocked for a reason other than a timeout xNextTaskUnblockTime is
		normally left unchanged, because it is automatically reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
#endif

	return xReturn;
}
/*-----------------------------------------------------------*/
// 将任务从受限事件列表移除
void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem, const TickType_t xItemValue)
{
	TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	// 由事件标志实施 需要调度器暂缓
	configASSERT(uxSchedulerSuspended != pdFALSE);

	/* Store the new item value in the event list. */
	// 设置事件列表值
	listSET_LIST_ITEM_VALUE(pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE);

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	// 从列表取出
	pxUnblockedTCB = (TCB_t *)listGET_LIST_ITEM_OWNER(pxEventListItem);
	configASSERT(pxUnblockedTCB);
	// 从事件列表移除
	(void)uxListRemove(pxEventListItem);

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	// 从状态列表移除(DEALY)
	(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
	// 加入到就序列表
	prvAddTaskToReadyList(pxUnblockedTCB);

	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority)
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
		// 等待调度求恢复 需要进行切换
	}
}
/*-----------------------------------------------------------*/

// 设置超时事件
void vTaskSetTimeOutState(TimeOut_t *const pxTimeOut)
{
	configASSERT(pxTimeOut);
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/
// 设置内部超时时间，不用临界区
void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut)
{
	/* For internal use only as it does not use a critical section. */
	// 记录计数器溢出次数
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	// 记录当前tick计数次数
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

// 检查是否超时
BaseType_t xTaskCheckForTimeOut(TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)
{
	BaseType_t xReturn;

	configASSERT(pxTimeOut);
	configASSERT(pxTicksToWait);

	// 进入临界区
	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		// 目前的tick计数值
		const TickType_t xConstTickCount = xTickCount;
		// 已经花费了的计数值
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;

#if (INCLUDE_xTaskAbortDelay == 1)
		if (pxCurrentTCB->ucDelayAborted != pdFALSE)
		{
			/* The delay was aborted, which is not the same as a time out,
			but has the same result. */
			pxCurrentTCB->ucDelayAborted = pdFALSE;
			xReturn = pdTRUE;
		}
		else
#endif

// 开启任务挂起
#if (INCLUDE_vTaskSuspend == 1)
			// 任务被无期限的挂起，不会超时
			if (*pxTicksToWait == portMAX_DELAY)
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
			}
			else
#endif
				// 记录的溢出次数和当前的溢出不相等 且 当前的计数值大于记录的计时次数
				if ((xNumOfOverflows != pxTimeOut->xOverflowCount) && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
				{
					/* The tick count is greater than the time at which
					vTaskSetTimeout() was called, but has also overflowed since
					vTaskSetTimeOut() was called.  It must have wrapped all the way
					around and gone past again. This passed since vTaskSetTimeout()
					was called. */
					xReturn = pdTRUE;
				}
				// 已经等待的时间小于超时时间
				else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
				{
					/* Not a genuine timeout. Adjust parameters for time remaining. */
					// 更新等待时间
					*pxTicksToWait -= xElapsedTime;
					// 重新设置超时时间
					vTaskInternalSetTimeOutState(pxTimeOut);
					xReturn = pdFALSE;
				}
				else
				{
					*pxTicksToWait = 0;
					xReturn = pdTRUE;
				}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskMissedYield(void)
{
	xYieldPending = pdTRUE;
}
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

// 获取任务的任务计数
UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask)
{
	UBaseType_t uxReturn;
	TCB_t *pxTCB;

	if (xTask != NULL)
	{
		pxTCB = (TCB_t *)xTask;
		uxReturn = pxTCB->uxTaskNumber;
	}
	else
	{
		uxReturn = 0U;
	}

	return uxReturn;
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

// 设置任务的任务计数
void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle)
{
	TCB_t *pxTCB;

	if (xTask != NULL)
	{
		pxTCB = (TCB_t *)xTask;
		pxTCB->uxTaskNumber = uxHandle;
	}
}

#endif /* configUSE_TRACE_FACILITY */

/*
 * -----------------------------------------------------------
 * The Idle task.
 * ----------------------------------------------------------
 *
 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for this function is:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
// 空闲任务
static portTASK_FUNCTION(prvIdleTask, pvParameters)
{
	/* Stop warnings. */
	(void)pvParameters;

	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
	SCHEDULER IS STARTED. **/

	/* In case a task that has a secure context deletes itself, in which case
	the idle task is responsible for deleting the task's secure context, if
	any. */
	portTASK_CALLS_SECURE_FUNCTIONS();

	for (;;)
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		// 检查需要被删除的任务列表(xTasksWaitingTermination)
		prvCheckTasksWaitingTermination();

// 未开启抢占式调度，idle任务功能完成，设置pendsv进行任务切换(主动放弃cpu)
#if (configUSE_PREEMPTION == 0)
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
		}
#endif /* configUSE_PREEMPTION */

// 开启了抢占式调度且有和空闲任务相同优先级的任务
#if ((configUSE_PREEMPTION == 1) && (configIDLE_SHOULD_YIELD == 1))
		{
			/* When using preemption tasks of equal priority will be
			timesliced.  If a task that is sharing the idle priority is ready
			to run then the idle task should yield before the end of the
			timeslice.

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */

			// 开启了抢占式调度且有和空闲任务有相同优先级的任务
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1)
			{
				// 空闲任务主动放弃cpu 交给同级任务
				taskYIELD();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */

// 钩子函数
#if (configUSE_IDLE_HOOK == 1)
		{
			extern void vApplicationIdleHook(void);

			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			// 在钩子函数 不能阻塞任务
			vApplicationIdleHook();
		}
#endif /* configUSE_IDLE_HOOK */

/* This conditional compilation should use inequality to 0, not equality
to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
user defined low power mode	implementations require
configUSE_TICKLESS_IDLE to be set to a value other than 1. */
// 低功耗相关
#if (configUSE_TICKLESS_IDLE != 0)
		{
			TickType_t xExpectedIdleTime;

			/* It is not desirable to suspend then resume the scheduler on
			each iteration of the idle task.  Therefore, a preliminary
			test of the expected idle time is performed without the
			scheduler suspended.  The result here is not necessarily
			valid. */
			xExpectedIdleTime = prvGetExpectedIdleTime();

			if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP)
			{
				vTaskSuspendAll();
				{
					/* Now the scheduler is suspended, the expected idle
					time can be sampled again, and this time its value can
					be used. */
					configASSERT(xNextTaskUnblockTime >= xTickCount);
					xExpectedIdleTime = prvGetExpectedIdleTime();

					/* Define the following macro to set xExpectedIdleTime to 0
					if the application does not want
					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING(xExpectedIdleTime);

					if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP)
					{
						traceLOW_POWER_IDLE_BEGIN();
						portSUPPRESS_TICKS_AND_SLEEP(xExpectedIdleTime);
						traceLOW_POWER_IDLE_END();
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				(void)xTaskResumeAll();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_TICKLESS_IDLE */
	}
}
/*-----------------------------------------------------------*/

#if (configUSE_TICKLESS_IDLE != 0)

// 确认睡眠模式状态
eSleepModeStatus eTaskConfirmSleepModeStatus(void)
{
	//空闲任务的加应用任务
	/* The idle task exists in addition to the application tasks. */
	const UBaseType_t uxNonApplicationTasks = 1;
	eSleepModeStatus eReturn = eStandardSleep;

	//延时唤醒任务列表不为空
	if (listCURRENT_LIST_LENGTH(&xPendingReadyList) != 0)
	{
		/* A task was made ready while the scheduler was suspended. */
		eReturn = eAbortSleep;
	}
	//需要重新调度
	else if (xYieldPending != pdFALSE)
	{
		/* A yield was pended while the scheduler was suspended. */
		eReturn = eAbortSleep;
	}
	else
	{
		/* If all the tasks are in the suspended list (which might mean they
		have an infinite block time rather than actually being suspended)
		then it is safe to turn all clocks off and just wait for external
		interrupts. */
		//如果所有的任务都进入了挂起列表，那么就可以安全的关闭中断和时钟
		if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == (uxCurrentNumberOfTasks - uxNonApplicationTasks))
		{
			eReturn = eNoTasksWaitingTimeout;
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return eReturn;
}

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)

// 设置线程本地存储指针
void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)
{
	TCB_t *pxTCB;

	if (xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS)
	{
		pxTCB = prvGetTCBFromHandle(xTaskToSet);
		pxTCB->pvThreadLocalStoragePointers[xIndex] = pvValue;
	}
}

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if (configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0)
// 获得线程本地存储指针
void *pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
	void *pvReturn = NULL;
	TCB_t *pxTCB;

	if (xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS)
	{
		pxTCB = prvGetTCBFromHandle(xTaskToQuery);
		pvReturn = pxTCB->pvThreadLocalStoragePointers[xIndex];
	}
	else
	{
		pvReturn = NULL;
	}

	return pvReturn;
}

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if (portUSING_MPU_WRAPPERS == 1)

void vTaskAllocateMPURegions(TaskHandle_t xTaskToModify, const MemoryRegion_t *const xRegions)
{
	TCB_t *pxTCB;

	/* If null is passed in here then we are modifying the MPU settings of
	the calling task. */
	pxTCB = prvGetTCBFromHandle(xTaskToModify);

	vPortStoreTaskMPUSettings(&(pxTCB->xMPUSettings), xRegions, NULL, 0);
}

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

// 初始化就绪链表
static void prvInitialiseTaskLists(void)
{
	UBaseType_t uxPriority;

	// 初始化不同优先级的任务列表
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++)
	{
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
	}
	// 初始化延迟列表和等待列表
	vListInitialise(&xDelayedTaskList1);
	vListInitialise(&xDelayedTaskList2);
	vListInitialise(&xPendingReadyList);

#if (INCLUDE_vTaskDelete == 1)
	{
		// 等待回收/删除的列表项
		vListInitialise(&xTasksWaitingTermination);
	}
#endif /* INCLUDE_vTaskDelete */

#if (INCLUDE_vTaskSuspend == 1)
	{
		// 被暂停的列表项
		vListInitialise(&xSuspendedTaskList);
	}
#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	// 当前正在使用的延时列表和溢出列表
	pxDelayedTaskList = &xDelayedTaskList1;
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination(void)
{

	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/

#if (INCLUDE_vTaskDelete == 1)
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U)
		{
			taskENTER_CRITICAL();
			{
				// 从xTasksWaitingTermination读出需要删除的TCB
				pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
				// 从xTasksWaitingTermination移除该TCB
				(void)uxListRemove(&(pxTCB->xStateListItem));
				// 当前的任务数
				--uxCurrentNumberOfTasks;
				// 等代清除的任务数
				--uxDeletedTasksWaitingCleanUp;
			}
			taskEXIT_CRITICAL();

			// 删除TCB
			prvDeleteTCB(pxTCB);
		}
	}
#endif /* INCLUDE_vTaskDelete */
}
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
	TCB_t *pxTCB;

	/* xTask is NULL then get the state of the calling task. */
	pxTCB = prvGetTCBFromHandle(xTask);

	// 句柄
	pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
	// task名
	pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
	// 当前运行权限
	pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
	// 栈的起始地址
	pxTaskStatus->pxStackBase = pxTCB->pxStack;
	// 被创建的第几个变量
	pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;

// 使用了互斥量
#if (configUSE_MUTEXES == 1)
	{
		pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
	}
#else
	{
		pxTaskStatus->uxBasePriority = 0;
	}
#endif

#if (configGENERATE_RUN_TIME_STATS == 1)
	{
		pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
	}
#else
	{
		pxTaskStatus->ulRunTimeCounter = 0;
	}
#endif

	/* Obtaining the task state is a little fiddly, so is only done if the
	value of eState passed into this function is eInvalid - otherwise the
	state is just set to whatever is passed in. */
	// 设置当前状态，当传入的状态不为eInvalid设置为出传入的值
	if (eState != eInvalid)
	{
		if (pxTCB == pxCurrentTCB)
		{
			pxTaskStatus->eCurrentState = eRunning;
		}
		else
		{
			pxTaskStatus->eCurrentState = eState;

#if (INCLUDE_vTaskSuspend == 1)
			{
				/* If the task is in the suspended list then there is a
				chance it is actually just blocked indefinitely - so really
				it should be reported as being in the Blocked state. */
				// 如果暂停列表有任务，那他可能只是被无限期的阻塞了
				if (eState == eSuspended)
				{
					vTaskSuspendAll();
					{
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL)
						{
							pxTaskStatus->eCurrentState = eBlocked;
						}
					}
					(void)xTaskResumeAll();
				}
			}
#endif /* INCLUDE_vTaskSuspend */
		}
	}
	else // 传入的是eInvalid
	{
		pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
	}

	/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
	parameter is provided to allow it to be skipped. */
	if (xGetFreeStackSpace != pdFALSE)
	{
#if (portSTACK_GROWTH > 0)
		{
			pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxEndOfStack);
		}
#else
		{ // 检查内存占用状态
			pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
		}
#endif
	}
	else
	{
		pxTaskStatus->usStackHighWaterMark = 0;
	}
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

// 从pxList中获取所有的pxTaskStatus信息，填充到pxTaskStatusArray
static UBaseType_t prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState)
{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	// 任务数
	UBaseType_t uxTask = 0;

	// 当前list不为空
	if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0)
	{
		// 获取到该list的下一个或者第一个tcb结构体
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);

		/* Populate an TaskStatus_t structure within the
		pxTaskStatusArray array for each task that is referenced from
		pxList.  See the definition of TaskStatus_t in task.h for the
		meaning of each TaskStatus_t structure member. */
		do
		{
			// 更新pxNextTCB
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
			// 从pxNextTCB中获取到pxTaskStatus信息并填充到pxTaskStatusArray中
			vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
			uxTask++;
		} while (pxNextTCB != pxFirstTCB); // 当填充的pxNextTCB等于pxFirstTCB结束填充
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return uxTask;
}

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) || (INCLUDE_uxTaskGetStackHighWaterMark == 1))

// 检查分配的栈的剩余空间
static uint16_t prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte)
{
	uint32_t ulCount = 0U;

	while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE)
	{
		pucStackByte -= portSTACK_GROWTH;
		ulCount++;
	}

	ulCount /= (uint32_t)sizeof(StackType_t); /*lint !e961 Casting is not redundant on smaller architectures. */

	return (uint16_t)ulCount;
}

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
/*-----------------------------------------------------------*/

#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)

// 获取栈的高位水平线
UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)
{
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

	pxTCB = prvGetTCBFromHandle(xTask);

#if portSTACK_GROWTH < 0
	{
		pucEndOfStack = (uint8_t *)pxTCB->pxStack;
	}
#else
	{
		pucEndOfStack = (uint8_t *)pxTCB->pxEndOfStack;
	}
#endif

	uxReturn = (UBaseType_t)prvTaskCheckFreeStackSpace(pucEndOfStack);

	return uxReturn;
}

#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
/*-----------------------------------------------------------*/

#if (INCLUDE_vTaskDelete == 1)

static void prvDeleteTCB(TCB_t *pxTCB)
{
	/* This call is required specifically for the TriCore port.  It must be
	above the vPortFree() calls.  The call is also used by ports/demos that
	want to allocate and clean RAM statically. */
	portCLEAN_UP_TCB(pxTCB);

/* Free up the memory allocated by the scheduler for the task.  It is up
to the task to free any memory allocated at the application level. */
#if (configUSE_NEWLIB_REENTRANT == 1)
	{
		_reclaim_reent(&(pxTCB->xNewLib_reent));
	}
#endif /* configUSE_NEWLIB_REENTRANT */

// 动态分配 无静态和mpu保护
#if ((configSUPPORT_DYNAMIC_ALLOCATION == 1) && (configSUPPORT_STATIC_ALLOCATION == 0) && (portUSING_MPU_WRAPPERS == 0))
	{
		/* The task can only have been allocated dynamically - free both
		the stack and TCB. */
		vPortFree(pxTCB->pxStack);
		vPortFree(pxTCB);
	}
	// 动态和静态分配
#elif (tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0) /*lint !e731 Macro has been consolidated for readability reasons. */
	{
		/* The task could have been allocated statically or dynamically, so
		check what was statically allocated before trying to free the
		memory. */
		// 动态分配的tcb 和 task
		if (pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB)
		{
			/* Both the stack and TCB were allocated dynamically, so both
			must be freed. */
			vPortFree(pxTCB->pxStack);
			vPortFree(pxTCB);
		}
		// 静态分配的tcb
		else if (pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY)
		{
			/* Only the stack was statically allocated, so the TCB is the
			only memory that must be freed. */
			vPortFree(pxTCB);
		}
		else
		{
			/* Neither the stack nor the TCB were allocated dynamically, so
			nothing needs to be freed. */
			configASSERT(pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB);
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif												   /* configSUPPORT_DYNAMIC_ALLOCATION */
}

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE)
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list.
		新的当前的延时列表是空的，设置下次唤醒时间为最大可能的值。这样在
		if( xTickCount >= xNextTaskUnblockTime ) 通过的概率极小，直到有一个项目在延迟列表中*/
		xNextTaskUnblockTime = portMAX_DELAY;
	}
	else
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state.
		新的当前延迟列表不为空，获取延迟列表最前面的节点，这是需要唤醒的时间从当前的阻塞状态唤醒 */
		(pxTCB) = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
	}
}
/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskGetCurrentTaskHandle == 1) || (configUSE_MUTEXES == 1))

// 当任务的句柄
TaskHandle_t xTaskGetCurrentTaskHandle(void)
{
	TaskHandle_t xReturn;

	/* A critical section is not required as this is not called from
	an interrupt and the current TCB will always be the same for any
	individual execution thread. */
	xReturn = pxCurrentTCB;

	return xReturn;
}

#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
/*-----------------------------------------------------------*/

#if ((INCLUDE_xTaskGetSchedulerState == 1) || (configUSE_TIMERS == 1))

// 获取调度器状态
BaseType_t xTaskGetSchedulerState(void)
{
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE)
	{
		xReturn = taskSCHEDULER_NOT_STARTED;
	}
	else
	{
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
		{
			xReturn = taskSCHEDULER_RUNNING;
		}
		else
		{
			xReturn = taskSCHEDULER_SUSPENDED;
		}
	}

	return xReturn;
}

#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

// 优先级继承
BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
	// 需要继承的任务tcb(当前占用信号量的任务)
	TCB_t *const pxMutexHolderTCB = (TCB_t *)pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

	/* If the mutex was given back by an interrupt while the queue was
	locked then the mutex holder might now be NULL.  _RB_ Is this still
	needed as interrupts can no longer use mutexes? */
	if (pxMutexHolder != NULL)
	{
		/* If the holder of the mutex has a priority below the priority of
		the task attempting to obtain the mutex then it will temporarily
		inherit the priority of the task attempting to obtain the mutex. */
		// 权限更小 短暂的继承当前任务的优先级，尝试获取互斥量的任务的优先级是大于或者等于
		// 未在运行的pxMutexHolder任务
		if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority)
		{
			/* Adjust the mutex holder state to account for its new
			priority.  Only reset the event list item value if the value is
			not being used for anything else. */
			// 根据新的优先级调整互斥器持有者状态。 只有当事件列表项的值不用于其他用途时，才重置该值
			if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
			{
				// 设置新值,记录当前优先级
				listSET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxCurrentTCB->uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task being modified is in the ready state it will need
			to be moved into a new list. */
			// 任务在就序列表中
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]), &(pxMutexHolderTCB->xStateListItem)) != pdFALSE)
			{
				// 从状态列表移除
				if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0)
				{
					taskRESET_READY_PRIORITY(pxMutexHolderTCB->uxPriority);
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* Inherit the priority before being moved into the new list. */
				// 继承优先级
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
				// 添加到新的就绪列表
				prvAddTaskToReadyList(pxMutexHolderTCB);
			}
			else
			{
				/* Just inherit the priority. */
				// 不在就绪列表 只update优先级
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
			}

			traceTASK_PRIORITY_INHERIT(pxMutexHolderTCB, pxCurrentTCB->uxPriority);

			/* Inheritance occurred. */
			xReturn = pdTRUE;
		}
		// pxMutexHolderTCB->uxPriority >= pxCurrentTCB->uxPriority
		else
		{
			if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority)
			{
				// current tcb的优先级 比 互斥量拥有者的优先级更高 继承失败
				/* The base priority of the mutex holder is lower than the
				priority of the task attempting to take the mutex, but the
				current priority of the mutex holder is not lower than the
				priority of the task attempting to take the mutex.
				Therefore the mutex holder must have already inherited a
				priority, but inheritance would have occurred if that had
				not been the case. */
				xReturn = pdTRUE;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

// 继承优先级剥夺
BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

	if (pxMutexHolder != NULL)
	{
		/* A task can only have an inherited priority if it holds the mutex.
		If the mutex is held by a task then it cannot be given from an
		interrupt, and if a mutex is given by the holding task then it must
		be the running state task. */
		// 任务只有在运行的时候才能继承优先级
		configASSERT(pxTCB == pxCurrentTCB);
		// 检查任务获取到的互斥量的个数
		configASSERT(pxTCB->uxMutexesHeld);
		// 任务获取到互斥量减少(释放)
		(pxTCB->uxMutexesHeld)--;

		/* Has the holder of the mutex inherited the priority of another
		task? */
		// 任务是否继承了优先级
		if (pxTCB->uxPriority != pxTCB->uxBasePriority)
		{
			// 任务只获得了该互斥量
			/* Only disinherit if no other mutexes are held. */
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0)
			{
				/* A task can only have an inherited priority if it holds
				the mutex.  If the mutex is held by a task then it cannot be
				given from an interrupt, and if a mutex is given by the
				holding task then it must be the running state task.  Remove
				the holding task from the ready list. */
				// 从就绪列表移除
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
				{
					taskRESET_READY_PRIORITY(pxTCB->uxPriority);
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* Disinherit the priority before adding the task into the
				new	ready list. */

				traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB->uxBasePriority);
				// 剥夺继承优先级，恢复成创建任务的优先级
				pxTCB->uxPriority = pxTCB->uxBasePriority;

				/* Reset the event list item value.  It cannot be in use for
				any other purpose if this task is running, and it must be
				running to give back the mutex. */
				// 重置事件列表项值
				listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)pxTCB->uxPriority); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				// 加到就绪列表
				prvAddTaskToReadyList(pxTCB);

				/* Return true to indicate that a context switch is required.
				This is only actually required in the corner case whereby
				multiple mutexes were held and the mutexes were given back
				in an order different to that in which they were taken.
				If a context switch did not occur when the first mutex was
				returned, even if a task was waiting on it, then a context
				switch should occur when the last mutex is returned whether
				a task is waiting on it or not. */
				// 由任务的优先级发生了改变 需要交换上下文
				xReturn = pdTRUE;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

// 重置优先级继承(超时后取消优先级继承?)
void vTaskPriorityDisinheritAfterTimeout(TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;

	if (pxMutexHolder != NULL)
	{
		/* If pxMutexHolder is not NULL then the holder must hold at least
		one mutex. */
		// 确保持有互斥量
		configASSERT(pxTCB->uxMutexesHeld);

		/* Determine the priority to which the priority of the task that
		holds the mutex should be set.  This will be the greater of the
		holding task's base priority and the priority of the highest
		priority task that is waiting to obtain the mutex.
		确定持有互斥任务的优先级,这将是持有任务的基本优先级和等待获得互斥任务
		的最高优先级任务的优先级中的较大值。*/

		// 任务的基础优先级和等待获取任务的优先级进行比较，设置最高的
		if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask)
		{
			uxPriorityToUse = uxHighestPriorityWaitingTask;
		}
		else
		{
			uxPriorityToUse = pxTCB->uxBasePriority;
		}

		// 互斥量持有者的优先级更低，目标优先级和当前优先级不一致
		/* Does the priority need to change? */
		if (pxTCB->uxPriority != uxPriorityToUse)
		{
			/* Only disinherit if no other mutexes are held.  This is a
			simplification in the priority inheritance implementation.  If
			the task that holds the mutex is also holding other mutexes then
			the other mutexes may have caused the priority inheritance. */
			// 当持有者只有当前的互斥量，才能重置，否则不能只参考当前的互斥量
			if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld)
			{
				/* If a task has timed out because it already holds the
				mutex it was trying to obtain then it cannot of inherited
				its own priority. */
				// 确保持有者不是当前的任务
				configASSERT(pxTCB != pxCurrentTCB);

				/* Disinherit the priority, remembering the previous
				priority to facilitate determining the subject task's
				state. */
				traceTASK_PRIORITY_DISINHERIT(pxTCB, pxTCB->uxBasePriority);
				// 备份持有者优先级
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
				// 更新持有者优先级
				pxTCB->uxPriority = uxPriorityToUse;

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				// 持有者没有其他事件
				if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL)
				{
					// 重置持有者事件节点值
					listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem), (TickType_t)configMAX_PRIORITIES - (TickType_t)uxPriorityToUse); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the running task is not the task that holds the mutex
				then the task that holds the mutex could be in either the
				Ready, Blocked or Suspended states.  Only remove the task
				from its current state list if it is in the Ready state as
				the task's priority is going to change and there is one
				Ready list per priority. */
				// 如果持有者处于就绪态，就需要更新就绪链表
				if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem)) != pdFALSE)
				{
					if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0)
					{
						taskRESET_READY_PRIORITY(pxTCB->uxPriority);
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					prvAddTaskToReadyList(pxTCB);
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (portCRITICAL_NESTING_IN_TCB == 1)

// 进入临界区
void vTaskEnterCritical(void)
{
	// 退出中断
	portDISABLE_INTERRUPTS();

	// 调度器运行状态
	if (xSchedulerRunning != pdFALSE)
	{
		// 嵌套次数加一
		(pxCurrentTCB->uxCriticalNesting)++;

		/* This is not the interrupt safe version of the enter critical
		function so	assert() if it is being called from an interrupt
		context.  Only API functions that end in "FromISR" can be used in an
		interrupt.  Only assert if the critical nesting count is 1 to
		protect against recursive calls if the assert function also uses a
		critical section. */
		if (pxCurrentTCB->uxCriticalNesting == 1)
		{
			portASSERT_IF_IN_ISR();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if (portCRITICAL_NESTING_IN_TCB == 1)
// 退出临界区
void vTaskExitCritical(void)
{
	//
	if (xSchedulerRunning != pdFALSE)
	{
		if (pxCurrentTCB->uxCriticalNesting > 0U)
		{
			// 减少嵌套深度
			(pxCurrentTCB->uxCriticalNesting)--;

			if (pxCurrentTCB->uxCriticalNesting == 0U)
			{
				// 打开中断
				portENABLE_INTERRUPTS();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0))

// 复制值到buff
static char *prvWriteNameToBuffer(char *pcBuffer, const char *pcTaskName)
{
	size_t x;

	/* Start by copying the entire string. */
	strcpy(pcBuffer, pcTaskName);

	/* Pad the end of the string with spaces to ensure columns line up when
	printed out. */
	// 为不够的值填充
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++)
	{
		pcBuffer[x] = ' ';
	}

	/* Terminate. */
	pcBuffer[x] = 0x00;

	/* Return the new end of string. */
	return &(pcBuffer[x]);
}

#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
/*-----------------------------------------------------------*/

#if ((configUSE_TRACE_FACILITY == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

// 分析任务状态
void vTaskList(char *pcWriteBuffer)
{
	TaskStatus_t *pxTaskStatusArray;
	volatile UBaseType_t uxArraySize, x;
	char cStatus;

	/*
	 * PLEASE NOTE:
	 *
	 * This function is provided for convenience only, and is used by many
	 * of the demo applications.  Do not consider it to be part of the
	 * scheduler.
	 * 该程序是为了方便，不要将其作为调度器的一部分
	 *
	 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
	 * uxTaskGetSystemState() output into a human readable table that
	 * displays task names, states and stack usage.
	 * 调用uxTaskGetSystemState()去获得可读性高的表格
	 *
	 * vTaskList() has a dependency on the sprintf() C library function that
	 * might bloat the code size, use a lot of stack, and provide different
	 * results on different platforms.  An alternative, tiny, third party,
	 * and limited functionality implementation of sprintf() is provided in
	 * many of the FreeRTOS/Demo sub-directories in a file called
	 * printf-stdarg.c (note printf-stdarg.c does not provide a full
	 * snprintf() implementation!).
	 *
	 * It is recommended that production systems call uxTaskGetSystemState()
	 * directly to get access to raw stats data, rather than indirectly
	 * through a call to vTaskList().
	 */

	/* Make sure the write buffer does not contain a string. */
	*pcWriteBuffer = 0x00;

	/* Take a snapshot of the number of tasks in case it changes while this
	function is executing. */
	// 快照保存，防止在该功能运行期间发生了改变
	uxArraySize = uxCurrentNumberOfTasks;

	/* Allocate an array index for each task.  NOTE!  if
	configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
	equate to NULL. */
	// 分配内存：TaskStatus_t * uxArraySize
	pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));

	if (pxTaskStatusArray != NULL)
	{
		/* Generate the (binary) data. */
		// 获取任务的状态
		uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, NULL);

		// 从二进制数据生成人类可读的表格
		/* Create a human readable table from the binary data. */
		for (x = 0; x < uxArraySize; x++)
		{
			switch (pxTaskStatusArray[x].eCurrentState)
			{
			case eRunning:
				cStatus = tskRUNNING_CHAR;
				break;

			case eReady:
				cStatus = tskREADY_CHAR;
				break;

			case eBlocked:
				cStatus = tskBLOCKED_CHAR;
				break;

			case eSuspended:
				cStatus = tskSUSPENDED_CHAR;
				break;

			case eDeleted:
				cStatus = tskDELETED_CHAR;
				break;

			default: /* Should not get here, but it is included
					 to prevent static checking errors. */
				cStatus = 0x00;
				break;
			}

			/* Write the task name to the string, padding with spaces so it
			can be printed in tabular form more easily. */
			// 任务的名字
			pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);

			/* Write the rest of the string. */
			// 拼接任务运行的状态、优先级、栈高位水平线、创建任务的index
			sprintf(pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, (unsigned int)pxTaskStatusArray[x].uxCurrentPriority, (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark, (unsigned int)pxTaskStatusArray[x].xTaskNumber);
			pcWriteBuffer += strlen(pcWriteBuffer);
		}

		/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
		is 0 then vPortFree() will be #defined to nothing. */
		vPortFree(pxTaskStatusArray);
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*----------------------------------------------------------*/

#if ((configGENERATE_RUN_TIME_STATS == 1) && (configUSE_STATS_FORMATTING_FUNCTIONS > 0) && (configSUPPORT_DYNAMIC_ALLOCATION == 1))

// 获取任务的运行事件状态
void vTaskGetRunTimeStats(char *pcWriteBuffer)
{
	TaskStatus_t *pxTaskStatusArray;
	volatile UBaseType_t uxArraySize, x;
	uint32_t ulTotalTime, ulStatsAsPercentage;

#if (configUSE_TRACE_FACILITY != 1)
	{
#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
	}
#endif

		/*
		 * PLEASE NOTE:
		 *
		 * This function is provided for convenience only, and is used by many
		 * of the demo applications.  Do not consider it to be part of the
		 * scheduler.
		 *
		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
		 * of the uxTaskGetSystemState() output into a human readable table that
		 * displays the amount of time each task has spent in the Running state
		 * in both absolute and percentage terms.
		 *
		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
		 * function that might bloat the code size, use a lot of stack, and
		 * provide different results on different platforms.  An alternative,
		 * tiny, third party, and limited functionality implementation of
		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
		 * a full snprintf() implementation!).
		 *
		 * It is recommended that production systems call uxTaskGetSystemState()
		 * directly to get access to raw stats data, rather than indirectly
		 * through a call to vTaskGetRunTimeStats().
		 */

		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = 0x00;

	/* Take a snapshot of the number of tasks in case it changes while this
	function is executing. */
	uxArraySize = uxCurrentNumberOfTasks;

	/* Allocate an array index for each task.  NOTE!  If
	configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
	equate to NULL. */
	pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));

	if (pxTaskStatusArray != NULL)
	{
		/* Generate the (binary) data. */
		// 读取所有的任务的运行状态，pxTaskStatus
		uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, &ulTotalTime);

		/* For percentage calculations. */
		ulTotalTime /= 100UL;

		/* Avoid divide by zero errors. */
		if (ulTotalTime > 0)
		{
			// 将数据转换成高阅读性文本
			/* Create a human readable table from the binary data. */
			for (x = 0; x < uxArraySize; x++)
			{
				/* What percentage of the total run time has the task used?
				This will always be rounded down to the nearest integer.
				ulTotalRunTimeDiv100 has already been divided by 100. */
				// 计算任务运行的事件占比
				ulStatsAsPercentage = pxTaskStatusArray[x].ulRunTimeCounter / ulTotalTime;

				/* Write the task name to the string, padding with
				spaces so it can be printed in tabular form more
				easily. */
				// 拼写成任务的名字
				pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);

				if (ulStatsAsPercentage > 0UL)
				{
#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
					{
						// 拼接运行事件和运行占比
						sprintf(pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[x].ulRunTimeCounter, ulStatsAsPercentage);
					}
#else
					{
						/* sizeof( int ) == sizeof( long ) so a smaller
						printf() library can be used. */
						sprintf(pcWriteBuffer, "\t%u\t\t%u%%\r\n", (unsigned int)pxTaskStatusArray[x].ulRunTimeCounter, (unsigned int)ulStatsAsPercentage);
					}
#endif
				}
				else
				{
/* If the percentage is zero here then the task has
consumed less than 1% of the total run time. */
#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
					{
						sprintf(pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[x].ulRunTimeCounter);
					}
#else
					{
						/* sizeof( int ) == sizeof( long ) so a smaller
						printf() library can be used. */
						sprintf(pcWriteBuffer, "\t%u\t\t<1%%\r\n", (unsigned int)pxTaskStatusArray[x].ulRunTimeCounter);
					}
#endif
				}

				pcWriteBuffer += strlen(pcWriteBuffer);
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
		is 0 then vPortFree() will be #defined to nothing. */
		vPortFree(pxTaskStatusArray);
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

// 重置事件列表项值
TickType_t uxTaskResetEventItemValue(void)
{
	TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem));

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xEventListItem), ((TickType_t)configMAX_PRIORITIES - (TickType_t)pxCurrentTCB->uxPriority)); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

// 任务持有的互斥量的个数
void *pvTaskIncrementMutexHeldCount(void)
{
	/* If xSemaphoreCreateMutex() is called before any tasks have been created
	then pxCurrentTCB will be NULL. */
	if (pxCurrentTCB != NULL)
	{
		(pxCurrentTCB->uxMutexesHeld)++;
	}

	return pxCurrentTCB;
}

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

// 任务等待通知
uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
	uint32_t ulReturn;

	// 进入临界区
	taskENTER_CRITICAL();
	{
		
		/* Only block if the notification count is not already non-zero. */
		//通知值为0 添加到延迟列表
		if (pxCurrentTCB->ulNotifiedValue == 0UL)
		{
			/* Mark this task as waiting for a notification. */
			// tcb状态为等待通知
			pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;

			// 等待时间不为0
			if (xTicksToWait > (TickType_t)0)
			{
				// 添加到等待列表，且可以无限等待
				prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
				traceTASK_NOTIFY_TAKE_BLOCK();

				/* All ports are written to allow a yield in a critical
				section (some will yield immediately, others wait until the
				critical section exits) - but it is not something that
				application code should ever do. */
				// 放弃cpu 任务切换
				portYIELD_WITHIN_API();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	// 打开中断
	taskEXIT_CRITICAL();
	
	//被通知
	taskENTER_CRITICAL();
	{
		traceTASK_NOTIFY_TAKE();
		// 通知值
		ulReturn = pxCurrentTCB->ulNotifiedValue;

		if (ulReturn != 0UL)
		{
			//退出时清除计数 true 
			if (xClearCountOnExit != pdFALSE)
			{
				// 清除通知值为0 (二进制信号作用)
				pxCurrentTCB->ulNotifiedValue = 0UL;
			}
			else
			{
				// 通知值减一(计数信号)
				pxCurrentTCB->ulNotifiedValue = ulReturn - (uint32_t)1;
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		// 设置任务为不等待通知
		pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
	}
	taskEXIT_CRITICAL();
	
	//返回通知值
	return ulReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)
// 任务等待通知 (ulTaskNotifyTake 高级版)
BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
	BaseType_t xReturn;

	taskENTER_CRITICAL();
	{
		/* Only block if a notification is not already pending. */
		// 任务不是收到通知的状态
		if (pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED)
		{
			/* Clear bits in the task's notification value as bits may get
			set	by the notifying task or interrupt.  This can be used to
			clear the value to zero. */
			// 清除通知位
			pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;

			/* Mark this task as waiting for a notification. */
			// 设置为等待的状态
			pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;

			//设置了超时时间
			if (xTicksToWait > (TickType_t)0)
			{
				// 添加到阻塞状态
				prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
				traceTASK_NOTIFY_WAIT_BLOCK();

				/* All ports are written to allow a yield in a critical
				section (some will yield immediately, others wait until the
				critical section exits) - but it is not something that
				application code should ever do. */
				// pendsv 放弃cpu 进行任务切换
				portYIELD_WITHIN_API();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	//退出临界区
	taskEXIT_CRITICAL();

	//进入临界区
	taskENTER_CRITICAL();
	{
		traceTASK_NOTIFY_WAIT();

		// 检查传递通知地址
		if (pulNotificationValue != NULL)
		{
			/* Output the current notification value, which may or may not
			have changed. */
			*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
		}

		/* If ucNotifyValue is set then either the task never entered the
		blocked state (because a notification was already pending) or the
		task unblocked because of a notification.  Otherwise the task
		unblocked because of a timeout. */

		// 唤醒后没有收到通知
		if (pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED)
		{
			/* A notification was not received. */
			//返回没有收到通知
			xReturn = pdFALSE;
		}
		// 接收到了通知
		else
		{
			/* A notification was already pending or a notification was
			received while the task was waiting. */
			// 清除退出位
			pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
			xReturn = pdTRUE;
		}

		// 设置不在等待通知
		pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
	}
	taskEXIT_CRITICAL();

	return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

// 通知某个任务

/*
函数名					TaskHandle_t	ulValue		eAction		pulPreviousNotificationValue
xTaskNotifyGive	   	    TaskHandle_t    0		    eIncrement  NULL
xTaskNotify  			TaskHandle_t    ulValue,    eAction     NULL
xTaskNotifyAndQuery 	TaskHandle_t	ulValue		eAction		pulPreviousNotificationValue
*/
BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue)
{
	TCB_t *pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

	configASSERT(xTaskToNotify);
	// 需要通知的任务的tcb
	pxTCB = (TCB_t *)xTaskToNotify;

	// 进入临界区
	taskENTER_CRITICAL();
	{
		if (pulPreviousNotificationValue != NULL)
		{
			// 记忆任务被通知之前的值
			*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
		}

		// 任务的原始通知状态
		ucOriginalNotifyState = pxTCB->ucNotifyState;

		// 设置通知状态 为接收到通知
		pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

		// 检查通知方式
		switch (eAction)
		{
		case eSetBits:
			// 设置位
			pxTCB->ulNotifiedValue |= ulValue;
			break;

		// 递增
		case eIncrement:
			(pxTCB->ulNotifiedValue)++;
			break;

		// 直接覆盖
		case eSetValueWithOverwrite:
			pxTCB->ulNotifiedValue = ulValue;
			break;

		// 通知值不为空则不覆盖
		case eSetValueWithoutOverwrite:
			if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED)
			{
				pxTCB->ulNotifiedValue = ulValue;
			}
			else
			{
				// 上次的通知值还未取走 丢弃
				/* The value could not be written to the task. */
				xReturn = pdFAIL;
			}
			break;

		case eNoAction:
			// 不更新此次
			/* The task is being notified without its notify value being
			updated. */
			break;
		}

		traceTASK_NOTIFY();

		/* If the task is in the blocked state specifically to wait for a
		notification then unblock it now. */
		// 原本是在等待通知的状态
		if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
		{
			// 取消延时
			(void)uxListRemove(&(pxTCB->xStateListItem));
			// 加入到就绪列表
			prvAddTaskToReadyList(pxTCB);

			/* The task should not have been on an event list. */
			// 必须没有是等待事件的状态,才能被通知
			configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

#if (configUSE_TICKLESS_IDLE != 0)
			{
				/* If a task is blocked waiting for a notification then
				xNextTaskUnblockTime might be set to the blocked task's time
				out time.  If the task is unblocked for a reason other than
				a timeout xNextTaskUnblockTime is normally left unchanged,
				because it will automatically get reset to a new value when
				the tick count equals xNextTaskUnblockTime.  However if
				tickless idling is used it might be more important to enter
				sleep mode at the earliest possible time - so reset
				xNextTaskUnblockTime here to ensure it is updated at the
				earliest possible time. */
				prvResetNextTaskUnblockTime();
			}
#endif

			// 被通知的任务权限更高 抢占调度
			if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
			{
				/* The notified task has a priority above the currently
				executing task so a yield is required. */
				taskYIELD_IF_USING_PREEMPTION();
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

// 中断通知某个任务
BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken)
{
	TCB_t *pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

	configASSERT(xTaskToNotify);

	/* RTOS ports that support interrupt nesting have the concept of a
	maximum	system call (or maximum API call) interrupt priority.
	Interrupts that are	above the maximum system call priority are keep
	permanently enabled, even when the RTOS kernel is in a critical section,
	but cannot make any calls to FreeRTOS API functions.  If configASSERT()
	is defined in FreeRTOSConfig.h then
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has
	been assigned a priority above the configured maximum system call
	priority.  Only FreeRTOS functions that end in FromISR can be called
	from interrupts	that have been assigned a priority at or (logically)
	below the maximum system call interrupt priority.  FreeRTOS maintains a
	separate interrupt safe API to ensure interrupt entry is as fast and as
	simple as possible.  More information (albeit Cortex-M specific) is
	provided on the following link:
	http://www.freertos.org/RTOS-Cortex-M3-M4.html */

	// 检查当前中断等级
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	pxTCB = (TCB_t *)xTaskToNotify;

	// 保存中断优先级
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if (pulPreviousNotificationValue != NULL)
		{
			// 回传通知值
			*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
		}

		// 先前通知状态
		ucOriginalNotifyState = pxTCB->ucNotifyState;
		// 现在通知状态
		pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

		// 设置通知值
		switch (eAction)
		{
		case eSetBits:
			pxTCB->ulNotifiedValue |= ulValue;
			break;

		case eIncrement:
			(pxTCB->ulNotifiedValue)++;
			break;

		case eSetValueWithOverwrite:
			pxTCB->ulNotifiedValue = ulValue;
			break;

		case eSetValueWithoutOverwrite:
			if (ucOriginalNotifyState != taskNOTIFICATION_RECEIVED)
			{
				pxTCB->ulNotifiedValue = ulValue;
			}
			else
			{
				/* The value could not be written to the task. */
				xReturn = pdFAIL;
			}
			break;

		case eNoAction:
			/* The task is being notified without its notify value being
			updated. */
			break;
		}

		traceTASK_NOTIFY_FROM_ISR();

		/* If the task is in the blocked state specifically to wait for a
		notification then unblock it now. */
		// 原始状态判断为等待通知(阻塞)
		if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
		{
			/* The task should not have been on an event list. */
			// 任务不应该在事件列表
			configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

			// 恢复调度
			if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
			{
				(void)uxListRemove(&(pxTCB->xStateListItem));
				prvAddTaskToReadyList(pxTCB);
			}
			else
			{
				/* The delayed and ready lists cannot be accessed, so hold
				this task pending until the scheduler is resumed. */
				vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
			}

			// 抢占式恢复
			if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
			{
				/* The notified task has a priority above the currently
				executing task so a yield is required. */
				if (pxHigherPriorityTaskWoken != NULL)
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
				}
				else
				{
					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);

	return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

// 通知任务isr
void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
	TCB_t *pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

	configASSERT(xTaskToNotify);

	/* RTOS ports that support interrupt nesting have the concept of a
	maximum	system call (or maximum API call) interrupt priority.
	Interrupts that are	above the maximum system call priority are keep
	permanently enabled, even when the RTOS kernel is in a critical section,
	but cannot make any calls to FreeRTOS API functions.  If configASSERT()
	is defined in FreeRTOSConfig.h then
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
	failure if a FreeRTOS API function is called from an interrupt that has
	been assigned a priority above the configured maximum system call
	priority.  Only FreeRTOS functions that end in FromISR can be called
	from interrupts	that have been assigned a priority at or (logically)
	below the maximum system call interrupt priority.  FreeRTOS maintains a
	separate interrupt safe API to ensure interrupt entry is as fast and as
	simple as possible.  More information (albeit Cortex-M specific) is
	provided on the following link:
	http://www.freertos.org/RTOS-Cortex-M3-M4.html */

	// 检查中断优先级
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	pxTCB = (TCB_t *)xTaskToNotify;

	// 关闭中断权限
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		// 保存先前的通知状态
		ucOriginalNotifyState = pxTCB->ucNotifyState;
		// 设置接收到通知
		pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

		/* 'Giving' is equivalent to incrementing a count in a counting
		semaphore. */
		// 增加通知值
		(pxTCB->ulNotifiedValue)++;

		traceTASK_NOTIFY_GIVE_FROM_ISR();

		/* If the task is in the blocked state specifically to wait for a
		notification then unblock it now. */
		// 被通知的任务处于阻塞状态
		if (ucOriginalNotifyState == taskWAITING_NOTIFICATION)
		{
			/* The task should not have been on an event list. */
			// 任务不应该处于等待状态
			configASSERT(listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL);

			// 恢复调度
			if (uxSchedulerSuspended == (UBaseType_t)pdFALSE)
			{
				(void)uxListRemove(&(pxTCB->xStateListItem));
				prvAddTaskToReadyList(pxTCB);
			}
			else
			{
				/* The delayed and ready lists cannot be accessed, so hold
				this task pending until the scheduler is resumed. */
				vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
			}

			// 抢占调度
			if (pxTCB->uxPriority > pxCurrentTCB->uxPriority)
			{
				/* The notified task has a priority above the currently
				executing task so a yield is required. */
				if (pxHigherPriorityTaskWoken != NULL)
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
				}
				else
				{
					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	// 恢复中断
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
}

#endif /* configUSE_TASK_NOTIFICATIONS */

/*-----------------------------------------------------------*/

#if (configUSE_TASK_NOTIFICATIONS == 1)

// 清除通知状态从等待到不等待
BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)
{
	TCB_t *pxTCB;
	BaseType_t xReturn;

	/* If null is passed in here then it is the calling task that is having
	its notification state cleared. */
	pxTCB = prvGetTCBFromHandle(xTask);

	taskENTER_CRITICAL();
	{
		if (pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED)
		{
			pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

// 添加现在的任务到延时列表
static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
	TickType_t xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;

#if (INCLUDE_xTaskAbortDelay == 1)
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	// 将task从就绪列表中移除
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0)
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY(pxCurrentTCB->uxPriority, uxTopReadyPriority);
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		// 休眠时间最大且开启了任务无限期休眠，将任务插入到暂缓列表
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE))
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		}
		// 休眠时间最大，且未开启任务暂停 和 休眠时间不是最大
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			// 计算下次唤醒时间
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			// 更改tcb的唤醒时间
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);

			if (xTimeToWake < xConstTickCount)
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				// 插到溢出列表
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				// 插入到延时列表
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime)
				{
					// 设置下次任务切换时间
					xNextTaskUnblockTime = xTimeToWake;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
	}
#else  /* INCLUDE_vTaskSuspend */
	// 不允许任务暂停
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);

		if (xTimeToWake < xConstTickCount)
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if (xTimeToWake < xNextTaskUnblockTime)
			{
				xNextTaskUnblockTime = xTimeToWake;
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}

/* Code below here allows additional code to be inserted into this source file,
especially where access to file scope functions and data is needed (for example
when performing module tests). */

#ifdef FREERTOS_MODULE_TEST
#include "tasks_test_access_functions.h"
#endif

#if (configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1)

#include "freertos_tasks_c_additions.h"

static void freertos_tasks_c_additions_init(void)
{
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
	FREERTOS_TASKS_C_ADDITIONS_INIT();
#endif
}

#endif
